{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.propKey = propKey;\nexports.intersection = intersection;\nexports.createRuleSet = createRuleSet;\nexports.createClassName = createClassName;\nexports.castBreakpointsToIntegers = castBreakpointsToIntegers;\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? Object(arguments[i]) : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/**\n * Extracts the single breakpoint prop from the props object.\n */\n\n\nfunction propKey(breakpointProps) {\n  return Object.keys(breakpointProps)[0];\n}\n/**\n * Returns the intersection of two arrays.\n */\n\n\nfunction intersection(a1, a2) {\n  return a2 ? a1.filter(function (element) {\n    return a2.indexOf(element) >= 0;\n  }) : _toConsumableArray(a1);\n}\n/**\n * Generate a style rule for a given class name that will hide the element\n * when the given query matches.\n */\n\n\nfunction createRuleSet(className, query) {\n  return \"@media \".concat(query, \"{.\").concat(className, \"{display:none!important;}}\");\n}\n/**\n * Given a list of strings, or string tuples, generates a class name.\n */\n\n\nfunction createClassName() {\n  for (var _len = arguments.length, components = new Array(_len), _key = 0; _key < _len; _key++) {\n    components[_key] = arguments[_key];\n  }\n\n  return [\"fresnel\"].concat(_toConsumableArray(components.reduce(function (acc, breakpoint) {\n    return Array.isArray(breakpoint) ? _toConsumableArray(acc).concat(_toConsumableArray(breakpoint)) : _toConsumableArray(acc).concat([breakpoint]);\n  }, []))).join(\"-\");\n}\n/**\n * Returns an object with every values casted to integers.\n */\n\n\nfunction castBreakpointsToIntegers(breakpoints) {\n  var keys = Object.keys(breakpoints);\n  return keys.reduce(function (previous, current, currentIndex) {\n    return _objectSpread({}, previous, _defineProperty({}, keys[currentIndex], Number(breakpoints[current])));\n  }, {});\n}","map":{"version":3,"sources":["../src/Utils.ts"],"names":["Object","a2","components","Array","keys","Number","breakpoints"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;AACA;;;AACO,SAAA,OAAA,CAAA,eAAA,EAAwD;AAC7D,SAAOA,MAAM,CAANA,IAAAA,CAAAA,eAAAA,EAAP,CAAOA,CAAP;AACD;AAED;AACA;AACA;;;AACO,SAAA,YAAA,CAAA,EAAA,EAAA,EAAA,EAGE;AACP,SAAOC,EAAE,GAAG,EAAE,CAAF,MAAA,CAAU,UAAA,OAAA,EAAO;AAAA,WAAIA,EAAE,CAAFA,OAAAA,CAAAA,OAAAA,KAAJ,CAAA;AAApB,GAAG,CAAH,GAAA,kBAAA,CAAT,EAAS,CAAT;AACD;AAED;AACA;AACA;AACA;;;AACO,SAAA,aAAA,CAAA,SAAA,EAAA,KAAA,EAAyD;AAC9D,SAAA,UAAA,MAAA,CAAA,KAAA,EAAA,IAAA,EAAA,MAAA,CAAA,SAAA,EAAA,4BAAA,CAAA;AACD;AAED;AACA;AACA;;;AACO,SAAA,eAAA,GAEL;AAAA,OAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EADGC,UACH,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AADGA,IAAAA,UACH,CAAA,IAAA,CADGA,GACH,SAAA,CAAA,IAAA,CADGA;AACH;;AACA,SAAO,CAAA,SAAA,EAAA,MAAA,CAAA,kBAAA,CAEF,UAAU,CAAV,MAAA,CACD,UAAA,GAAA,EAAA,UAAA,EAAA;AAAA,WACEC,KAAK,CAALA,OAAAA,CAAAA,UAAAA,IAAAA,kBAAAA,CAAAA,GAAAA,CAAAA,CAAAA,MAAAA,CAAAA,kBAAAA,CAAAA,UAAAA,CAAAA,CAAAA,GAAAA,kBAAAA,CAAAA,GAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CADF,UACEA,CAAAA,CADF;AADC,GAAA,EAFE,EAEF,CAFE,CAAA,EAAA,IAAA,CAAP,GAAO,CAAP;AAUD;AAED;AACA;AACA;;;AACO,SAAA,yBAAA,CAAA,WAAA,EAEuB;AAC5B,MAAMC,IAAI,GAAGJ,MAAM,CAANA,IAAAA,CAAb,WAAaA,CAAb;AAEA,SAAO,IAAI,CAAJ,MAAA,CACL,UAAA,QAAA,EAAA,OAAA,EAAA,YAAA,EAAA;AAAA,WAAA,aAAA,CAAA,EAAA,EAAA,QAAA,EAAA,eAAA,CAAA,EAAA,EAEGI,IAAI,CAFP,YAEO,CAFP,EAEwBC,MAAM,CAACC,WAAW,CAF1C,OAE0C,CAAZ,CAF9B,CAAA,CAAA;AADK,GAAA,EAAP,EAAO,CAAP;AAOD","sourcesContent":["import { MediaBreakpointProps } from \"./Media\"\nimport { BreakpointConstraintKey } from \"./Breakpoints\"\n\n/**\n * Extracts the single breakpoint prop from the props object.\n */\nexport function propKey(breakpointProps: MediaBreakpointProps) {\n  return Object.keys(breakpointProps)[0] as BreakpointConstraintKey\n}\n\n/**\n * Returns the intersection of two arrays.\n */\nexport function intersection(\n  a1: ReadonlyArray<any>,\n  a2?: ReadonlyArray<any>\n): any[] {\n  return a2 ? a1.filter(element => a2.indexOf(element) >= 0) : [...a1]\n}\n\n/**\n * Generate a style rule for a given class name that will hide the element\n * when the given query matches.\n */\nexport function createRuleSet(className: string, query: string) {\n  return `@media ${query}{.${className}{display:none!important;}}`\n}\n\n/**\n * Given a list of strings, or string tuples, generates a class name.\n */\nexport function createClassName(\n  ...components: Array<string | [string, string]>\n) {\n  return [\n    \"fresnel\",\n    ...components.reduce(\n      (acc: string[], breakpoint) =>\n        Array.isArray(breakpoint)\n          ? [...acc, ...breakpoint]\n          : [...acc, breakpoint],\n      []\n    ),\n  ].join(\"-\")\n}\n\n/**\n * Returns an object with every values casted to integers.\n */\nexport function castBreakpointsToIntegers(breakpoints: {\n  [key: string]: number | string\n}): { [key: string]: number } {\n  const keys = Object.keys(breakpoints)\n\n  return keys.reduce(\n    (previous, current, currentIndex) => ({\n      ...previous,\n      [keys[currentIndex]]: Number(breakpoints[current]),\n    }),\n    {}\n  )\n}\n"]},"metadata":{},"sourceType":"script"}