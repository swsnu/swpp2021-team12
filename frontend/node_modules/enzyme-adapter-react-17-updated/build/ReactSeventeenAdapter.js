"use strict";

var _object = _interopRequireDefault(require("object.assign"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _server = _interopRequireDefault(require("react-dom/server"));

var _shallow = _interopRequireDefault(require("react-test-renderer/shallow"));

var _package = require("react-test-renderer/package.json");

var _testUtils = _interopRequireDefault(require("react-dom/test-utils"));

var _semver = _interopRequireDefault(require("semver"));

var _checkPropTypes2 = _interopRequireDefault(require("prop-types/checkPropTypes"));

var _has = _interopRequireDefault(require("has"));

var _reactIs = require("react-is");

var _enzyme = require("enzyme");

var _Utils = require("enzyme/build/Utils");

var _enzymeShallowEqual = _interopRequireDefault(require("enzyme-shallow-equal"));

var _enzymeAdapterUtils = require("enzyme-adapter-utils");

var _findCurrentFiberUsingSlowPath = _interopRequireDefault(require("./findCurrentFiberUsingSlowPath"));

var _detectFiberTags = _interopRequireDefault(require("./detectFiberTags"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var is164 = !!_testUtils["default"].Simulate.touchStart; // 16.4+

var is165 = !!_testUtils["default"].Simulate.auxClick; // 16.5+

var is166 = is165 && !_react["default"].unstable_AsyncMode; // 16.6+

var is168 = is166 && typeof _testUtils["default"].act === 'function';

var hasShouldComponentUpdateBug = _semver["default"].satisfies(_package.version, '< 16.8'); // Lazily populated if DOM is available.


var FiberTags = null;

function nodeAndSiblingsArray(nodeWithSibling) {
  var array = [];
  var node = nodeWithSibling;

  while (node != null) {
    array.push(node);
    node = node.sibling;
  }

  return array;
}

function flatten(arr) {
  var result = [];
  var stack = [{
    i: 0,
    array: arr
  }];

  while (stack.length) {
    var n = stack.pop();

    while (n.i < n.array.length) {
      var el = n.array[n.i];
      n.i += 1;

      if (Array.isArray(el)) {
        stack.push(n);
        stack.push({
          i: 0,
          array: el
        });
        break;
      }

      result.push(el);
    }
  }

  return result;
}

function nodeTypeFromType(type) {
  if (type === _reactIs.Portal) {
    return 'portal';
  }

  return (0, _enzymeAdapterUtils.nodeTypeFromType)(type);
}

function isMemo(type) {
  return (0, _enzymeAdapterUtils.compareNodeTypeOf)(type, _reactIs.Memo);
}

function isLazy(type) {
  return (0, _enzymeAdapterUtils.compareNodeTypeOf)(type, _reactIs.Lazy);
}

function unmemoType(type) {
  return isMemo(type) ? type.type : type;
}

function checkIsSuspenseAndCloneElement(el, _ref) {
  var suspenseFallback = _ref.suspenseFallback;

  if (!(0, _reactIs.isSuspense)(el)) {
    return el;
  }

  var children = el.props.children;

  if (suspenseFallback) {
    var fallback = el.props.fallback;
    children = replaceLazyWithFallback(children, fallback);
  }

  var FakeSuspenseWrapper = function FakeSuspenseWrapper(props) {
    return /*#__PURE__*/_react["default"].createElement(el.type, _objectSpread(_objectSpread({}, el.props), props), children);
  };

  return /*#__PURE__*/_react["default"].createElement(FakeSuspenseWrapper, null, children);
}

function elementToTree(el) {
  if (!(0, _reactIs.isPortal)(el)) {
    return (0, _enzymeAdapterUtils.elementToTree)(el, elementToTree);
  }

  var children = el.children,
      containerInfo = el.containerInfo;
  var props = {
    children: children,
    containerInfo: containerInfo
  };
  return {
    nodeType: 'portal',
    type: _reactIs.Portal,
    props: props,
    key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(el.key),
    ref: el.ref || null,
    instance: null,
    rendered: elementToTree(el.children)
  };
}

function _toTree(vnode) {
  if (vnode == null) {
    return null;
  } // TODO(lmr): I'm not really sure I understand whether or not this is what
  // i should be doing, or if this is a hack for something i'm doing wrong
  // somewhere else. Should talk to sebastian about this perhaps


  var node = (0, _findCurrentFiberUsingSlowPath["default"])(vnode);

  switch (node.tag) {
    case FiberTags.HostRoot:
      return childrenToTree(node.child);

    case FiberTags.HostPortal:
      {
        var containerInfo = node.stateNode.containerInfo,
            children = node.memoizedProps;
        var props = {
          containerInfo: containerInfo,
          children: children
        };
        return {
          nodeType: 'portal',
          type: _reactIs.Portal,
          props: props,
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }

    case FiberTags.ClassComponent:
      return {
        nodeType: 'class',
        type: node.type,
        props: _objectSpread({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: node.stateNode,
        rendered: childrenToTree(node.child)
      };

    case FiberTags.FunctionalComponent:
      return {
        nodeType: 'function',
        type: node.type,
        props: _objectSpread({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: null,
        rendered: childrenToTree(node.child)
      };

    case FiberTags.MemoClass:
      return {
        nodeType: 'class',
        type: node.elementType.type,
        props: _objectSpread({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: node.stateNode,
        rendered: childrenToTree(node.child.child)
      };

    case FiberTags.MemoSFC:
      {
        var renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(_toTree));

        if (renderedNodes.length === 0) {
          renderedNodes = [node.memoizedProps.children];
        }

        return {
          nodeType: 'function',
          type: node.elementType,
          props: _objectSpread({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: renderedNodes
        };
      }

    case FiberTags.HostComponent:
      {
        var _renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(_toTree));

        if (_renderedNodes.length === 0) {
          _renderedNodes = [node.memoizedProps.children];
        }

        return {
          nodeType: 'host',
          type: node.type,
          props: _objectSpread({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: node.stateNode,
          rendered: _renderedNodes
        };
      }

    case FiberTags.HostText:
      return node.memoizedProps;

    case FiberTags.Fragment:
    case FiberTags.Mode:
    case FiberTags.ContextProvider:
    case FiberTags.ContextConsumer:
      return childrenToTree(node.child);

    case FiberTags.Profiler:
    case FiberTags.ForwardRef:
      {
        return {
          nodeType: 'function',
          type: node.type,
          props: _objectSpread({}, node.pendingProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }

    case FiberTags.Suspense:
      {
        return {
          nodeType: 'function',
          type: _reactIs.Suspense,
          props: _objectSpread({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }

    case FiberTags.Lazy:
      return childrenToTree(node.child);

    case FiberTags.OffscreenComponent:
      return _toTree(node.child);

    default:
      throw new Error("Enzyme Internal Error: unknown node with tag ".concat(node.tag));
  }
}

function childrenToTree(node) {
  if (!node) {
    return null;
  }

  var children = nodeAndSiblingsArray(node);

  if (children.length === 0) {
    return null;
  }

  if (children.length === 1) {
    return _toTree(children[0]);
  }

  return flatten(children.map(_toTree));
}

function _nodeToHostNode(_node) {
  // NOTE(lmr): node could be a function component
  // which wont have an instance prop, but we can get the
  // host node associated with its return value at that point.
  // Although this breaks down if the return value is an array,
  // as is possible with React 16.
  var node = _node;

  while (node && !Array.isArray(node) && node.instance === null) {
    node = node.rendered;
  } // if the SFC returned null effectively, there is no host node.


  if (!node) {
    return null;
  }

  var mapper = function mapper(item) {
    if (item && item.instance) return _reactDom["default"].findDOMNode(item.instance);
    return null;
  };

  if (Array.isArray(node)) {
    return node.map(mapper);
  }

  if (Array.isArray(node.rendered) && node.nodeType === 'class') {
    return node.rendered.map(mapper);
  }

  return mapper(node);
}

function replaceLazyWithFallback(node, fallback) {
  if (!node) {
    return null;
  }

  if (Array.isArray(node)) {
    return node.map(function (el) {
      return replaceLazyWithFallback(el, fallback);
    });
  }

  if (isLazy(node.type)) {
    return fallback;
  }

  return _objectSpread(_objectSpread({}, node), {}, {
    props: _objectSpread(_objectSpread({}, node.props), {}, {
      children: replaceLazyWithFallback(node.props.children, fallback)
    })
  });
}

var eventOptions = {
  animation: true,
  pointerEvents: is164,
  auxClick: is165
};

function getEmptyStateValue() {
  // this handles a bug in React 16.0 - 16.2
  // see https://github.com/facebook/react/commit/39be83565c65f9c522150e52375167568a2a1459
  // also see https://github.com/facebook/react/pull/11965
  var EmptyState = /*#__PURE__*/function (_React$Component) {
    _inherits(EmptyState, _React$Component);

    var _super = _createSuper(EmptyState);

    function EmptyState() {
      _classCallCheck(this, EmptyState);

      return _super.apply(this, arguments);
    }

    _createClass(EmptyState, [{
      key: "render",
      value: function render() {
        return null;
      }
    }]);

    return EmptyState;
  }(_react["default"].Component);

  var testRenderer = new _shallow["default"]();
  testRenderer.render( /*#__PURE__*/_react["default"].createElement(EmptyState));
  return testRenderer._instance.state;
}

function wrapAct(fn) {
  if (!is168) {
    return fn();
  }

  var returnVal;

  _testUtils["default"].act(function () {
    returnVal = fn();
  });

  return returnVal;
}

function getProviderDefaultValue(Provider) {
  // React stores references to the Provider's defaultValue differently across versions.
  if ('_defaultValue' in Provider._context) {
    return Provider._context._defaultValue;
  }

  if ('_currentValue' in Provider._context) {
    return Provider._context._currentValue;
  }

  throw new Error('Enzyme Internal Error: can’t figure out how to get Provider’s default value');
}

function makeFakeElement(type) {
  return {
    $$typeof: _reactIs.Element,
    type: type
  };
}

function isStateful(Component) {
  return Component.prototype && (Component.prototype.isReactComponent || Array.isArray(Component.__reactAutoBindPairs) // fallback for createClass components
  );
}

var ReactSeventeenAdapter = /*#__PURE__*/function (_EnzymeAdapter) {
  _inherits(ReactSeventeenAdapter, _EnzymeAdapter);

  var _super2 = _createSuper(ReactSeventeenAdapter);

  function ReactSeventeenAdapter() {
    var _this;

    _classCallCheck(this, ReactSeventeenAdapter);

    _this = _super2.call(this);
    var lifecycles = _this.options.lifecycles;
    _this.options = _objectSpread(_objectSpread({}, _this.options), {}, {
      enableComponentDidUpdateOnSetState: true,
      // TODO: remove, semver-major
      legacyContextMode: 'parent',
      lifecycles: _objectSpread(_objectSpread({}, lifecycles), {}, {
        componentDidUpdate: {
          onSetState: true
        },
        getDerivedStateFromProps: {
          hasShouldComponentUpdateBug: hasShouldComponentUpdateBug
        },
        getSnapshotBeforeUpdate: true,
        setState: {
          skipsComponentDidUpdateOnNullish: true
        },
        getChildContext: {
          calledByRenderer: false
        },
        getDerivedStateFromError: is166
      })
    });
    return _this;
  }

  _createClass(ReactSeventeenAdapter, [{
    key: "createMountRenderer",
    value: function createMountRenderer(options) {
      (0, _enzymeAdapterUtils.assertDomAvailable)('mount');

      if ((0, _has["default"])(options, 'suspenseFallback')) {
        throw new TypeError('`suspenseFallback` is not supported by the `mount` renderer');
      }

      if (FiberTags === null) {
        // Requires DOM.
        FiberTags = (0, _detectFiberTags["default"])();
      }

      var attachTo = options.attachTo,
          hydrateIn = options.hydrateIn,
          wrappingComponentProps = options.wrappingComponentProps;
      var domNode = hydrateIn || attachTo || global.document.createElement('div');
      var instance = null;
      var adapter = this;
      return _objectSpread({
        render: function render(el, context, callback) {
          return wrapAct(function () {
            if (instance === null) {
              var type = el.type,
                  props = el.props,
                  ref = el.ref;

              var wrapperProps = _objectSpread({
                Component: type,
                props: props,
                wrappingComponentProps: wrappingComponentProps,
                context: context
              }, ref && {
                refProp: ref
              });

              var ReactWrapperComponent = (0, _enzymeAdapterUtils.createMountWrapper)(el, _objectSpread(_objectSpread({}, options), {}, {
                adapter: adapter
              }));

              var wrappedEl = /*#__PURE__*/_react["default"].createElement(ReactWrapperComponent, wrapperProps);

              instance = hydrateIn ? _reactDom["default"].hydrate(wrappedEl, domNode) : _reactDom["default"].render(wrappedEl, domNode);

              if (typeof callback === 'function') {
                callback();
              }
            } else {
              instance.setChildProps(el.props, context, callback);
            }
          });
        },
        unmount: function unmount() {
          _reactDom["default"].unmountComponentAtNode(domNode);

          instance = null;
        },
        getNode: function getNode() {
          if (!instance) {
            return null;
          }

          return (0, _enzymeAdapterUtils.getNodeFromRootFinder)(adapter.isCustomComponent, _toTree(instance._reactInternals), options);
        },
        simulateError: function simulateError(nodeHierarchy, rootNode, error) {
          var isErrorBoundary = function isErrorBoundary(_ref2) {
            var elInstance = _ref2.instance,
                type = _ref2.type;

            if (is166 && type && type.getDerivedStateFromError) {
              return true;
            }

            return elInstance && elInstance.componentDidCatch;
          };

          var _ref3 = nodeHierarchy.find(isErrorBoundary) || {},
              catchingInstance = _ref3.instance,
              catchingType = _ref3.type;

          (0, _enzymeAdapterUtils.simulateError)(error, catchingInstance, rootNode, nodeHierarchy, nodeTypeFromType, adapter.displayNameOfNode, is166 ? catchingType : undefined);
        },
        simulateEvent: function simulateEvent(node, event, mock) {
          var mappedEvent = (0, _enzymeAdapterUtils.mapNativeEventNames)(event, eventOptions);
          var eventFn = _testUtils["default"].Simulate[mappedEvent];

          if (!eventFn) {
            throw new TypeError("ReactWrapper::simulate() event '".concat(event, "' does not exist"));
          }

          wrapAct(function () {
            eventFn(adapter.nodeToHostNode(node), mock);
          });
        },
        batchedUpdates: function batchedUpdates(fn) {
          return fn(); // return ReactDOM.unstable_batchedUpdates(fn);
        },
        getWrappingComponentRenderer: function getWrappingComponentRenderer() {
          return _objectSpread(_objectSpread({}, this), (0, _enzymeAdapterUtils.getWrappingComponentMountRenderer)({
            toTree: function toTree(inst) {
              return _toTree(inst._reactInternals);
            },
            getMountWrapperInstance: function getMountWrapperInstance() {
              return instance;
            }
          }));
        }
      }, is168 && {
        wrapInvoke: wrapAct
      });
    }
  }, {
    key: "createShallowRenderer",
    value: function createShallowRenderer() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var adapter = this;
      var renderer = new _shallow["default"]();
      var suspenseFallback = options.suspenseFallback;

      if (typeof suspenseFallback !== 'undefined' && typeof suspenseFallback !== 'boolean') {
        throw TypeError('`options.suspenseFallback` should be boolean or undefined');
      }

      var isDOM = false;
      var cachedNode = null;
      var lastComponent = null;
      var wrappedComponent = null;
      var sentinel = {}; // wrap memo components with a PureComponent, or a class component with sCU

      var wrapPureComponent = function wrapPureComponent(Component, compare) {
        if (!is166) {
          throw new RangeError('this function should not be called in React < 16.6. Please report this!');
        }

        if (lastComponent !== Component) {
          if (isStateful(Component)) {
            wrappedComponent = /*#__PURE__*/function (_Component) {
              _inherits(wrappedComponent, _Component);

              var _super3 = _createSuper(wrappedComponent);

              function wrappedComponent() {
                _classCallCheck(this, wrappedComponent);

                return _super3.apply(this, arguments);
              }

              return wrappedComponent;
            }(Component);

            if (compare) {
              wrappedComponent.prototype.shouldComponentUpdate = function (nextProps) {
                return !compare(_this2.props, nextProps);
              };
            } else {
              wrappedComponent.prototype.isPureReactComponent = true;
            }
          } else {
            var memoized = sentinel;
            var prevProps;

            wrappedComponent = function wrappedComponentFn(props) {
              var shouldUpdate = memoized === sentinel || (compare ? !compare(prevProps, props) : !(0, _enzymeShallowEqual["default"])(prevProps, props));

              if (shouldUpdate) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }

                memoized = Component.apply(void 0, [_objectSpread(_objectSpread({}, Component.defaultProps), props)].concat(args));
                prevProps = props;
              }

              return memoized;
            };
          }

          (0, _object["default"])(wrappedComponent, Component, {
            displayName: adapter.displayNameOfNode({
              type: Component
            })
          });
          lastComponent = Component;
        }

        return wrappedComponent;
      }; // Wrap functional components on versions prior to 16.5,
      // to avoid inadvertently pass a `this` instance to it.


      var wrapFunctionalComponent = function wrapFunctionalComponent(Component) {
        if (is166 && (0, _has["default"])(Component, 'defaultProps')) {
          if (lastComponent !== Component) {
            wrappedComponent = (0, _object["default"])( // eslint-disable-next-line new-cap
            function (props) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }

              return Component.apply(void 0, [_objectSpread(_objectSpread({}, Component.defaultProps), props)].concat(args));
            }, Component, {
              displayName: adapter.displayNameOfNode({
                type: Component
              })
            });
            lastComponent = Component;
          }

          return wrappedComponent;
        }

        if (is165) {
          return Component;
        }

        if (lastComponent !== Component) {
          wrappedComponent = (0, _object["default"])(function () {
            return Component.apply(void 0, arguments);
          }, // eslint-disable-line new-cap
          Component);
          lastComponent = Component;
        }

        return wrappedComponent;
      };

      var renderElement = function renderElement(elConfig) {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          rest[_key3 - 1] = arguments[_key3];
        }

        var renderedEl = renderer.render.apply(renderer, [elConfig].concat(rest));
        var typeIsExisted = !!(renderedEl && renderedEl.type);

        if (is166 && typeIsExisted) {
          var clonedEl = checkIsSuspenseAndCloneElement(renderedEl, {
            suspenseFallback: suspenseFallback
          });
          var elementIsChanged = clonedEl.type !== renderedEl.type;

          if (elementIsChanged) {
            return renderer.render.apply(renderer, [_objectSpread(_objectSpread({}, elConfig), {}, {
              type: clonedEl.type
            })].concat(rest));
          }
        }

        return renderedEl;
      };

      return {
        render: function render(el, unmaskedContext) {
          var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
              _ref4$providerValues = _ref4.providerValues,
              providerValues = _ref4$providerValues === void 0 ? new Map() : _ref4$providerValues;

          cachedNode = el;
          /* eslint consistent-return: 0 */

          if (typeof el.type === 'string') {
            isDOM = true;
          } else if ((0, _reactIs.isContextProvider)(el)) {
            providerValues.set(el.type, el.props.value);
            var MockProvider = (0, _object["default"])(function (props) {
              return props.children;
            }, el.type);
            return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              return renderElement(_objectSpread(_objectSpread({}, el), {}, {
                type: MockProvider
              }));
            });
          } else if ((0, _reactIs.isContextConsumer)(el)) {
            var Provider = adapter.getProviderFromConsumer(el.type);
            var value = providerValues.has(Provider) ? providerValues.get(Provider) : getProviderDefaultValue(Provider);
            var MockConsumer = (0, _object["default"])(function (props) {
              return props.children(value);
            }, el.type);
            return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              return renderElement(_objectSpread(_objectSpread({}, el), {}, {
                type: MockConsumer
              }));
            });
          } else {
            isDOM = false;
            var renderedEl = el;

            if (isLazy(renderedEl)) {
              throw TypeError('`React.lazy` is not supported by shallow rendering.');
            }

            renderedEl = checkIsSuspenseAndCloneElement(renderedEl, {
              suspenseFallback: suspenseFallback
            });
            var _renderedEl = renderedEl,
                Component = _renderedEl.type;
            var context = (0, _enzymeAdapterUtils.getMaskedContext)(Component.contextTypes, unmaskedContext);

            if (isMemo(el.type)) {
              var _el$type = el.type,
                  InnerComp = _el$type.type,
                  compare = _el$type.compare;
              return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                return renderElement(_objectSpread(_objectSpread({}, el), {}, {
                  type: wrapPureComponent(InnerComp, compare)
                }), context);
              });
            }

            if (!isStateful(Component) && typeof Component === 'function') {
              return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                return renderElement(_objectSpread(_objectSpread({}, renderedEl), {}, {
                  type: wrapFunctionalComponent(Component)
                }), context);
              });
            }

            if (isStateful) {
              // fix react bug; see implementation of `getEmptyStateValue`
              var emptyStateValue = getEmptyStateValue();

              if (emptyStateValue) {
                Object.defineProperty(Component.prototype, 'state', {
                  configurable: true,
                  enumerable: true,
                  get: function get() {
                    return null;
                  },
                  set: function set(value) {
                    if (value !== emptyStateValue) {
                      Object.defineProperty(this, 'state', {
                        configurable: true,
                        enumerable: true,
                        value: value,
                        writable: true
                      });
                    }

                    return true;
                  }
                });
              }
            }

            return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              return renderElement(renderedEl, context);
            });
          }
        },
        unmount: function unmount() {
          renderer.unmount();
        },
        getNode: function getNode() {
          if (isDOM) {
            return elementToTree(cachedNode);
          }

          var output = renderer.getRenderOutput();
          return {
            nodeType: nodeTypeFromType(cachedNode.type),
            type: cachedNode.type,
            props: cachedNode.props,
            key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(cachedNode.key),
            ref: cachedNode.ref,
            instance: renderer._instance,
            rendered: Array.isArray(output) ? flatten(output).map(function (el) {
              return elementToTree(el);
            }) : elementToTree(output)
          };
        },
        simulateError: function simulateError(nodeHierarchy, rootNode, error) {
          (0, _enzymeAdapterUtils.simulateError)(error, renderer._instance, cachedNode, nodeHierarchy.concat(cachedNode), nodeTypeFromType, adapter.displayNameOfNode, is166 ? cachedNode.type : undefined);
        },
        simulateEvent: function simulateEvent(node, event) {
          for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
            args[_key4 - 2] = arguments[_key4];
          }

          var handler = node.props[(0, _enzymeAdapterUtils.propFromEvent)(event, eventOptions)];

          if (handler) {
            (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              // TODO(lmr): create/use synthetic events
              // TODO(lmr): emulate React's event propagation
              // ReactDOM.unstable_batchedUpdates(() => {
              handler.apply(void 0, args); // });
            });
          }
        },
        batchedUpdates: function batchedUpdates(fn) {
          return fn(); // return ReactDOM.unstable_batchedUpdates(fn);
        },
        checkPropTypes: function checkPropTypes(typeSpecs, values, location, hierarchy) {
          return (0, _checkPropTypes2["default"])(typeSpecs, values, location, (0, _enzymeAdapterUtils.displayNameOfNode)(cachedNode), function () {
            return (0, _enzymeAdapterUtils.getComponentStack)(hierarchy.concat([cachedNode]));
          });
        }
      };
    }
  }, {
    key: "createStringRenderer",
    value: function createStringRenderer(options) {
      if ((0, _has["default"])(options, 'suspenseFallback')) {
        throw new TypeError('`suspenseFallback` should not be specified in options of string renderer');
      }

      return {
        render: function render(el, context) {
          if (options.context && (el.type.contextTypes || options.childContextTypes)) {
            var childContextTypes = _objectSpread(_objectSpread({}, el.type.contextTypes || {}), options.childContextTypes);

            var ContextWrapper = (0, _enzymeAdapterUtils.createRenderWrapper)(el, context, childContextTypes);
            return _server["default"].renderToStaticMarkup( /*#__PURE__*/_react["default"].createElement(ContextWrapper));
          }

          return _server["default"].renderToStaticMarkup(el);
        }
      };
    } // Provided a bag of options, return an `EnzymeRenderer`. Some options can be implementation
    // specific, like `attach` etc. for React, but not part of this interface explicitly.
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "createRenderer",
    value: function createRenderer(options) {
      switch (options.mode) {
        case _enzyme.EnzymeAdapter.MODES.MOUNT:
          return this.createMountRenderer(options);

        case _enzyme.EnzymeAdapter.MODES.SHALLOW:
          return this.createShallowRenderer(options);

        case _enzyme.EnzymeAdapter.MODES.STRING:
          return this.createStringRenderer(options);

        default:
          throw new Error("Enzyme Internal Error: Unrecognized mode: ".concat(options.mode));
      }
    }
  }, {
    key: "wrap",
    value: function wrap(element) {
      return (0, _enzymeAdapterUtils.wrap)(element);
    } // converts an RSTNode to the corresponding JSX Pragma Element. This will be needed
    // in order to implement the `Wrapper.mount()` and `Wrapper.shallow()` methods, but should
    // be pretty straightforward for people to implement.
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "nodeToElement",
    value: function nodeToElement(node) {
      if (!node || _typeof(node) !== 'object') return null;
      var type = node.type;
      return /*#__PURE__*/_react["default"].createElement(unmemoType(type), (0, _enzymeAdapterUtils.propsWithKeysAndRef)(node));
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "matchesElementType",
    value: function matchesElementType(node, matchingType) {
      if (!node) {
        return node;
      }

      var type = node.type;
      return unmemoType(type) === unmemoType(matchingType);
    }
  }, {
    key: "elementToNode",
    value: function elementToNode(element) {
      return elementToTree(element);
    }
  }, {
    key: "nodeToHostNode",
    value: function nodeToHostNode(node) {
      var supportsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var nodes = _nodeToHostNode(node);

      if (Array.isArray(nodes) && !supportsArray) {
        return nodes[0];
      }

      return nodes;
    }
  }, {
    key: "displayNameOfNode",
    value: function displayNameOfNode(node) {
      if (!node) return null;
      var type = node.type,
          $$typeof = node.$$typeof;
      var nodeType = type || $$typeof; // newer node types may be undefined, so only test if the nodeType exists

      if (nodeType) {
        switch (nodeType) {
          case (is166 ? _reactIs.ConcurrentMode : _reactIs.AsyncMode) || NaN:
            return is166 ? 'ConcurrentMode' : 'AsyncMode';

          case _reactIs.Fragment || NaN:
            return 'Fragment';

          case _reactIs.StrictMode || NaN:
            return 'StrictMode';

          case _reactIs.Profiler || NaN:
            return 'Profiler';

          case _reactIs.Portal || NaN:
            return 'Portal';

          case _reactIs.Suspense || NaN:
            return 'Suspense';

          default:
        }
      }

      var $$typeofType = type && type.$$typeof;

      switch ($$typeofType) {
        case _reactIs.ContextConsumer || NaN:
          return 'ContextConsumer';

        case _reactIs.ContextProvider || NaN:
          return 'ContextProvider';

        case _reactIs.Memo || NaN:
          {
            var nodeName = (0, _enzymeAdapterUtils.displayNameOfNode)(node);
            return typeof nodeName === 'string' ? nodeName : "Memo(".concat((0, _enzymeAdapterUtils.displayNameOfNode)(type), ")");
          }

        case _reactIs.ForwardRef || NaN:
          {
            if (type.displayName) {
              return type.displayName;
            }

            var name = (0, _enzymeAdapterUtils.displayNameOfNode)({
              type: type.render
            });
            return name ? "ForwardRef(".concat(name, ")") : 'ForwardRef';
          }

        case _reactIs.Lazy || NaN:
          {
            return 'lazy';
          }

        default:
          return (0, _enzymeAdapterUtils.displayNameOfNode)(node);
      }
    }
  }, {
    key: "isValidElement",
    value: function isValidElement(element) {
      return (0, _reactIs.isElement)(element);
    }
  }, {
    key: "isValidElementType",
    value: function isValidElementType(object) {
      return !!object && (0, _reactIs.isValidElementType)(object);
    }
  }, {
    key: "isFragment",
    value: function isFragment(fragment) {
      return (0, _Utils.typeOfNode)(fragment) === _reactIs.Fragment;
    }
  }, {
    key: "isCustomComponent",
    value: function isCustomComponent(type) {
      var fakeElement = makeFakeElement(type);
      return !!type && (typeof type === 'function' || (0, _reactIs.isForwardRef)(fakeElement) || (0, _reactIs.isContextProvider)(fakeElement) || (0, _reactIs.isContextConsumer)(fakeElement) || (0, _reactIs.isSuspense)(fakeElement));
    }
  }, {
    key: "isContextConsumer",
    value: function isContextConsumer(type) {
      return !!type && (0, _reactIs.isContextConsumer)(makeFakeElement(type));
    }
  }, {
    key: "isCustomComponentElement",
    value: function isCustomComponentElement(inst) {
      if (!inst || !this.isValidElement(inst)) {
        return false;
      }

      return this.isCustomComponent(inst.type);
    }
  }, {
    key: "getProviderFromConsumer",
    value: function getProviderFromConsumer(Consumer) {
      // React stores references to the Provider on a Consumer differently across versions.
      if (Consumer) {
        var Provider;

        if (Consumer._context) {
          // check this first, to avoid a deprecation warning
          Provider = Consumer._context.Provider;
        } else if (Consumer.Provider) {
          Provider = Consumer.Provider;
        }

        if (Provider) {
          return Provider;
        }
      }

      throw new Error('Enzyme Internal Error: can’t figure out how to get Provider from Consumer');
    }
  }, {
    key: "createElement",
    value: function createElement() {
      return /*#__PURE__*/_react["default"].createElement.apply(_react["default"], arguments);
    }
  }, {
    key: "wrapWithWrappingComponent",
    value: function wrapWithWrappingComponent(node, options) {
      return {
        RootFinder: _enzymeAdapterUtils.RootFinder,
        node: (0, _enzymeAdapterUtils.wrapWithWrappingComponent)(_react["default"].createElement, node, options)
      };
    }
  }]);

  return ReactSeventeenAdapter;
}(_enzyme.EnzymeAdapter);

module.exports = ReactSeventeenAdapter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SZWFjdFNldmVudGVlbkFkYXB0ZXIuanMiXSwibmFtZXMiOlsiaXMxNjQiLCJUZXN0VXRpbHMiLCJTaW11bGF0ZSIsInRvdWNoU3RhcnQiLCJpczE2NSIsImF1eENsaWNrIiwiaXMxNjYiLCJSZWFjdCIsInVuc3RhYmxlX0FzeW5jTW9kZSIsImlzMTY4IiwiYWN0IiwiaGFzU2hvdWxkQ29tcG9uZW50VXBkYXRlQnVnIiwic2VtdmVyIiwic2F0aXNmaWVzIiwidGVzdFJlbmRlcmVyVmVyc2lvbiIsIkZpYmVyVGFncyIsIm5vZGVBbmRTaWJsaW5nc0FycmF5Iiwibm9kZVdpdGhTaWJsaW5nIiwiYXJyYXkiLCJub2RlIiwicHVzaCIsInNpYmxpbmciLCJmbGF0dGVuIiwiYXJyIiwicmVzdWx0Iiwic3RhY2siLCJpIiwibGVuZ3RoIiwibiIsInBvcCIsImVsIiwiQXJyYXkiLCJpc0FycmF5Iiwibm9kZVR5cGVGcm9tVHlwZSIsInR5cGUiLCJQb3J0YWwiLCJpc01lbW8iLCJNZW1vIiwiaXNMYXp5IiwiTGF6eSIsInVubWVtb1R5cGUiLCJjaGVja0lzU3VzcGVuc2VBbmRDbG9uZUVsZW1lbnQiLCJzdXNwZW5zZUZhbGxiYWNrIiwiY2hpbGRyZW4iLCJwcm9wcyIsImZhbGxiYWNrIiwicmVwbGFjZUxhenlXaXRoRmFsbGJhY2siLCJGYWtlU3VzcGVuc2VXcmFwcGVyIiwiY3JlYXRlRWxlbWVudCIsImVsZW1lbnRUb1RyZWUiLCJjb250YWluZXJJbmZvIiwibm9kZVR5cGUiLCJrZXkiLCJyZWYiLCJpbnN0YW5jZSIsInJlbmRlcmVkIiwidG9UcmVlIiwidm5vZGUiLCJ0YWciLCJIb3N0Um9vdCIsImNoaWxkcmVuVG9UcmVlIiwiY2hpbGQiLCJIb3N0UG9ydGFsIiwic3RhdGVOb2RlIiwibWVtb2l6ZWRQcm9wcyIsIkNsYXNzQ29tcG9uZW50IiwiRnVuY3Rpb25hbENvbXBvbmVudCIsIk1lbW9DbGFzcyIsImVsZW1lbnRUeXBlIiwiTWVtb1NGQyIsInJlbmRlcmVkTm9kZXMiLCJtYXAiLCJIb3N0Q29tcG9uZW50IiwiSG9zdFRleHQiLCJGcmFnbWVudCIsIk1vZGUiLCJDb250ZXh0UHJvdmlkZXIiLCJDb250ZXh0Q29uc3VtZXIiLCJQcm9maWxlciIsIkZvcndhcmRSZWYiLCJwZW5kaW5nUHJvcHMiLCJTdXNwZW5zZSIsIk9mZnNjcmVlbkNvbXBvbmVudCIsIkVycm9yIiwibm9kZVRvSG9zdE5vZGUiLCJfbm9kZSIsIm1hcHBlciIsIml0ZW0iLCJSZWFjdERPTSIsImZpbmRET01Ob2RlIiwiZXZlbnRPcHRpb25zIiwiYW5pbWF0aW9uIiwicG9pbnRlckV2ZW50cyIsImdldEVtcHR5U3RhdGVWYWx1ZSIsIkVtcHR5U3RhdGUiLCJDb21wb25lbnQiLCJ0ZXN0UmVuZGVyZXIiLCJTaGFsbG93UmVuZGVyZXIiLCJyZW5kZXIiLCJfaW5zdGFuY2UiLCJzdGF0ZSIsIndyYXBBY3QiLCJmbiIsInJldHVyblZhbCIsImdldFByb3ZpZGVyRGVmYXVsdFZhbHVlIiwiUHJvdmlkZXIiLCJfY29udGV4dCIsIl9kZWZhdWx0VmFsdWUiLCJfY3VycmVudFZhbHVlIiwibWFrZUZha2VFbGVtZW50IiwiJCR0eXBlb2YiLCJFbGVtZW50IiwiaXNTdGF0ZWZ1bCIsInByb3RvdHlwZSIsImlzUmVhY3RDb21wb25lbnQiLCJfX3JlYWN0QXV0b0JpbmRQYWlycyIsIlJlYWN0U2V2ZW50ZWVuQWRhcHRlciIsImxpZmVjeWNsZXMiLCJvcHRpb25zIiwiZW5hYmxlQ29tcG9uZW50RGlkVXBkYXRlT25TZXRTdGF0ZSIsImxlZ2FjeUNvbnRleHRNb2RlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwib25TZXRTdGF0ZSIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwic2V0U3RhdGUiLCJza2lwc0NvbXBvbmVudERpZFVwZGF0ZU9uTnVsbGlzaCIsImdldENoaWxkQ29udGV4dCIsImNhbGxlZEJ5UmVuZGVyZXIiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJUeXBlRXJyb3IiLCJhdHRhY2hUbyIsImh5ZHJhdGVJbiIsIndyYXBwaW5nQ29tcG9uZW50UHJvcHMiLCJkb21Ob2RlIiwiZ2xvYmFsIiwiZG9jdW1lbnQiLCJhZGFwdGVyIiwiY29udGV4dCIsImNhbGxiYWNrIiwid3JhcHBlclByb3BzIiwicmVmUHJvcCIsIlJlYWN0V3JhcHBlckNvbXBvbmVudCIsIndyYXBwZWRFbCIsImh5ZHJhdGUiLCJzZXRDaGlsZFByb3BzIiwidW5tb3VudCIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJnZXROb2RlIiwiaXNDdXN0b21Db21wb25lbnQiLCJfcmVhY3RJbnRlcm5hbHMiLCJzaW11bGF0ZUVycm9yIiwibm9kZUhpZXJhcmNoeSIsInJvb3ROb2RlIiwiZXJyb3IiLCJpc0Vycm9yQm91bmRhcnkiLCJlbEluc3RhbmNlIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJmaW5kIiwiY2F0Y2hpbmdJbnN0YW5jZSIsImNhdGNoaW5nVHlwZSIsImRpc3BsYXlOYW1lT2ZOb2RlIiwidW5kZWZpbmVkIiwic2ltdWxhdGVFdmVudCIsImV2ZW50IiwibW9jayIsIm1hcHBlZEV2ZW50IiwiZXZlbnRGbiIsImJhdGNoZWRVcGRhdGVzIiwiZ2V0V3JhcHBpbmdDb21wb25lbnRSZW5kZXJlciIsImluc3QiLCJnZXRNb3VudFdyYXBwZXJJbnN0YW5jZSIsIndyYXBJbnZva2UiLCJyZW5kZXJlciIsImlzRE9NIiwiY2FjaGVkTm9kZSIsImxhc3RDb21wb25lbnQiLCJ3cmFwcGVkQ29tcG9uZW50Iiwic2VudGluZWwiLCJ3cmFwUHVyZUNvbXBvbmVudCIsImNvbXBhcmUiLCJSYW5nZUVycm9yIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwibmV4dFByb3BzIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJtZW1vaXplZCIsInByZXZQcm9wcyIsIndyYXBwZWRDb21wb25lbnRGbiIsInNob3VsZFVwZGF0ZSIsImFyZ3MiLCJkZWZhdWx0UHJvcHMiLCJkaXNwbGF5TmFtZSIsIndyYXBGdW5jdGlvbmFsQ29tcG9uZW50IiwicmVuZGVyRWxlbWVudCIsImVsQ29uZmlnIiwicmVzdCIsInJlbmRlcmVkRWwiLCJ0eXBlSXNFeGlzdGVkIiwiY2xvbmVkRWwiLCJlbGVtZW50SXNDaGFuZ2VkIiwidW5tYXNrZWRDb250ZXh0IiwicHJvdmlkZXJWYWx1ZXMiLCJNYXAiLCJzZXQiLCJ2YWx1ZSIsIk1vY2tQcm92aWRlciIsImdldFByb3ZpZGVyRnJvbUNvbnN1bWVyIiwiaGFzIiwiZ2V0IiwiTW9ja0NvbnN1bWVyIiwiY29udGV4dFR5cGVzIiwiSW5uZXJDb21wIiwiZW1wdHlTdGF0ZVZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJvdXRwdXQiLCJnZXRSZW5kZXJPdXRwdXQiLCJjb25jYXQiLCJoYW5kbGVyIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImhpZXJhcmNoeSIsImNoaWxkQ29udGV4dFR5cGVzIiwiQ29udGV4dFdyYXBwZXIiLCJSZWFjdERPTVNlcnZlciIsInJlbmRlclRvU3RhdGljTWFya3VwIiwibW9kZSIsIkVuenltZUFkYXB0ZXIiLCJNT0RFUyIsIk1PVU5UIiwiY3JlYXRlTW91bnRSZW5kZXJlciIsIlNIQUxMT1ciLCJjcmVhdGVTaGFsbG93UmVuZGVyZXIiLCJTVFJJTkciLCJjcmVhdGVTdHJpbmdSZW5kZXJlciIsImVsZW1lbnQiLCJtYXRjaGluZ1R5cGUiLCJzdXBwb3J0c0FycmF5Iiwibm9kZXMiLCJDb25jdXJyZW50TW9kZSIsIkFzeW5jTW9kZSIsIk5hTiIsIlN0cmljdE1vZGUiLCIkJHR5cGVvZlR5cGUiLCJub2RlTmFtZSIsIm5hbWUiLCJvYmplY3QiLCJmcmFnbWVudCIsImZha2VFbGVtZW50IiwiaXNWYWxpZEVsZW1lbnQiLCJDb25zdW1lciIsIlJvb3RGaW5kZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoi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XHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xyXG5pbXBvcnQgUmVhY3RET01TZXJ2ZXIgZnJvbSAncmVhY3QtZG9tL3NlcnZlcic7XHJcbmltcG9ydCBTaGFsbG93UmVuZGVyZXIgZnJvbSAncmVhY3QtdGVzdC1yZW5kZXJlci9zaGFsbG93JztcclxuaW1wb3J0IHsgdmVyc2lvbiBhcyB0ZXN0UmVuZGVyZXJWZXJzaW9uIH0gZnJvbSAncmVhY3QtdGVzdC1yZW5kZXJlci9wYWNrYWdlLmpzb24nO1xyXG5pbXBvcnQgVGVzdFV0aWxzIGZyb20gJ3JlYWN0LWRvbS90ZXN0LXV0aWxzJztcclxuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xyXG5pbXBvcnQgY2hlY2tQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcyc7XHJcbmltcG9ydCBoYXMgZnJvbSAnaGFzJztcclxuaW1wb3J0IHtcclxuICBBc3luY01vZGUsXHJcbiAgQ29uY3VycmVudE1vZGUsXHJcbiAgQ29udGV4dENvbnN1bWVyLFxyXG4gIENvbnRleHRQcm92aWRlcixcclxuICBFbGVtZW50LFxyXG4gIEZvcndhcmRSZWYsXHJcbiAgRnJhZ21lbnQsXHJcbiAgaXNDb250ZXh0Q29uc3VtZXIsXHJcbiAgaXNDb250ZXh0UHJvdmlkZXIsXHJcbiAgaXNFbGVtZW50LFxyXG4gIGlzRm9yd2FyZFJlZixcclxuICBpc1BvcnRhbCxcclxuICBpc1N1c3BlbnNlLFxyXG4gIGlzVmFsaWRFbGVtZW50VHlwZSxcclxuICBMYXp5LFxyXG4gIE1lbW8sXHJcbiAgUG9ydGFsLFxyXG4gIFByb2ZpbGVyLFxyXG4gIFN0cmljdE1vZGUsXHJcbiAgU3VzcGVuc2UsXHJcbn0gZnJvbSAncmVhY3QtaXMnO1xyXG5pbXBvcnQgeyBFbnp5bWVBZGFwdGVyIH0gZnJvbSAnZW56eW1lJztcclxuaW1wb3J0IHsgdHlwZU9mTm9kZSB9IGZyb20gJ2VuenltZS9idWlsZC9VdGlscyc7XHJcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnZW56eW1lLXNoYWxsb3ctZXF1YWwnO1xyXG5pbXBvcnQge1xyXG4gIGRpc3BsYXlOYW1lT2ZOb2RlLFxyXG4gIGVsZW1lbnRUb1RyZWUgYXMgdXRpbEVsZW1lbnRUb1RyZWUsXHJcbiAgbm9kZVR5cGVGcm9tVHlwZSBhcyB1dGlsTm9kZVR5cGVGcm9tVHlwZSxcclxuICBtYXBOYXRpdmVFdmVudE5hbWVzLFxyXG4gIHByb3BGcm9tRXZlbnQsXHJcbiAgYXNzZXJ0RG9tQXZhaWxhYmxlLFxyXG4gIHdpdGhTZXRTdGF0ZUFsbG93ZWQsXHJcbiAgY3JlYXRlUmVuZGVyV3JhcHBlcixcclxuICBjcmVhdGVNb3VudFdyYXBwZXIsXHJcbiAgcHJvcHNXaXRoS2V5c0FuZFJlZixcclxuICBlbnN1cmVLZXlPclVuZGVmaW5lZCxcclxuICBzaW11bGF0ZUVycm9yLFxyXG4gIHdyYXAsXHJcbiAgZ2V0TWFza2VkQ29udGV4dCxcclxuICBnZXRDb21wb25lbnRTdGFjayxcclxuICBSb290RmluZGVyLFxyXG4gIGdldE5vZGVGcm9tUm9vdEZpbmRlcixcclxuICB3cmFwV2l0aFdyYXBwaW5nQ29tcG9uZW50LFxyXG4gIGdldFdyYXBwaW5nQ29tcG9uZW50TW91bnRSZW5kZXJlcixcclxuICBjb21wYXJlTm9kZVR5cGVPZixcclxufSBmcm9tICdlbnp5bWUtYWRhcHRlci11dGlscyc7XHJcbmltcG9ydCBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCBmcm9tICcuL2ZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoJztcclxuaW1wb3J0IGRldGVjdEZpYmVyVGFncyBmcm9tICcuL2RldGVjdEZpYmVyVGFncyc7XHJcblxyXG5jb25zdCBpczE2NCA9ICEhVGVzdFV0aWxzLlNpbXVsYXRlLnRvdWNoU3RhcnQ7IC8vIDE2LjQrXHJcbmNvbnN0IGlzMTY1ID0gISFUZXN0VXRpbHMuU2ltdWxhdGUuYXV4Q2xpY2s7IC8vIDE2LjUrXHJcbmNvbnN0IGlzMTY2ID0gaXMxNjUgJiYgIVJlYWN0LnVuc3RhYmxlX0FzeW5jTW9kZTsgLy8gMTYuNitcclxuY29uc3QgaXMxNjggPSBpczE2NiAmJiB0eXBlb2YgVGVzdFV0aWxzLmFjdCA9PT0gJ2Z1bmN0aW9uJztcclxuXHJcbmNvbnN0IGhhc1Nob3VsZENvbXBvbmVudFVwZGF0ZUJ1ZyA9IHNlbXZlci5zYXRpc2ZpZXModGVzdFJlbmRlcmVyVmVyc2lvbiwgJzwgMTYuOCcpO1xyXG5cclxuLy8gTGF6aWx5IHBvcHVsYXRlZCBpZiBET00gaXMgYXZhaWxhYmxlLlxyXG5sZXQgRmliZXJUYWdzID0gbnVsbDtcclxuXHJcbmZ1bmN0aW9uIG5vZGVBbmRTaWJsaW5nc0FycmF5KG5vZGVXaXRoU2libGluZykge1xyXG4gIGNvbnN0IGFycmF5ID0gW107XHJcbiAgbGV0IG5vZGUgPSBub2RlV2l0aFNpYmxpbmc7XHJcbiAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xyXG4gICAgYXJyYXkucHVzaChub2RlKTtcclxuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XHJcbiAgfVxyXG4gIHJldHVybiBhcnJheTtcclxufVxyXG5cclxuZnVuY3Rpb24gZmxhdHRlbihhcnIpIHtcclxuICBjb25zdCByZXN1bHQgPSBbXTtcclxuICBjb25zdCBzdGFjayA9IFt7IGk6IDAsIGFycmF5OiBhcnIgfV07XHJcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xyXG4gICAgY29uc3QgbiA9IHN0YWNrLnBvcCgpO1xyXG4gICAgd2hpbGUgKG4uaSA8IG4uYXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IGVsID0gbi5hcnJheVtuLmldO1xyXG4gICAgICBuLmkgKz0gMTtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWwpKSB7XHJcbiAgICAgICAgc3RhY2sucHVzaChuKTtcclxuICAgICAgICBzdGFjay5wdXNoKHsgaTogMCwgYXJyYXk6IGVsIH0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHJlc3VsdC5wdXNoKGVsKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gbm9kZVR5cGVGcm9tVHlwZSh0eXBlKSB7XHJcbiAgaWYgKHR5cGUgPT09IFBvcnRhbCkge1xyXG4gICAgcmV0dXJuICdwb3J0YWwnO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHV0aWxOb2RlVHlwZUZyb21UeXBlKHR5cGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc01lbW8odHlwZSkge1xyXG4gIHJldHVybiBjb21wYXJlTm9kZVR5cGVPZih0eXBlLCBNZW1vKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNMYXp5KHR5cGUpIHtcclxuICByZXR1cm4gY29tcGFyZU5vZGVUeXBlT2YodHlwZSwgTGF6eSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVubWVtb1R5cGUodHlwZSkge1xyXG4gIHJldHVybiBpc01lbW8odHlwZSkgPyB0eXBlLnR5cGUgOiB0eXBlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0lzU3VzcGVuc2VBbmRDbG9uZUVsZW1lbnQoZWwsIHsgc3VzcGVuc2VGYWxsYmFjayB9KSB7XHJcbiAgaWYgKCFpc1N1c3BlbnNlKGVsKSkge1xyXG4gICAgcmV0dXJuIGVsO1xyXG4gIH1cclxuXHJcbiAgbGV0IHsgY2hpbGRyZW4gfSA9IGVsLnByb3BzO1xyXG5cclxuICBpZiAoc3VzcGVuc2VGYWxsYmFjaykge1xyXG4gICAgY29uc3QgeyBmYWxsYmFjayB9ID0gZWwucHJvcHM7XHJcbiAgICBjaGlsZHJlbiA9IHJlcGxhY2VMYXp5V2l0aEZhbGxiYWNrKGNoaWxkcmVuLCBmYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBGYWtlU3VzcGVuc2VXcmFwcGVyID0gKHByb3BzKSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KFxyXG4gICAgZWwudHlwZSxcclxuICAgIHsgLi4uZWwucHJvcHMsIC4uLnByb3BzIH0sXHJcbiAgICBjaGlsZHJlbixcclxuICApO1xyXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEZha2VTdXNwZW5zZVdyYXBwZXIsIG51bGwsIGNoaWxkcmVuKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZWxlbWVudFRvVHJlZShlbCkge1xyXG4gIGlmICghaXNQb3J0YWwoZWwpKSB7XHJcbiAgICByZXR1cm4gdXRpbEVsZW1lbnRUb1RyZWUoZWwsIGVsZW1lbnRUb1RyZWUpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBjaGlsZHJlbiwgY29udGFpbmVySW5mbyB9ID0gZWw7XHJcbiAgY29uc3QgcHJvcHMgPSB7IGNoaWxkcmVuLCBjb250YWluZXJJbmZvIH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBub2RlVHlwZTogJ3BvcnRhbCcsXHJcbiAgICB0eXBlOiBQb3J0YWwsXHJcbiAgICBwcm9wcyxcclxuICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQoZWwua2V5KSxcclxuICAgIHJlZjogZWwucmVmIHx8IG51bGwsXHJcbiAgICBpbnN0YW5jZTogbnVsbCxcclxuICAgIHJlbmRlcmVkOiBlbGVtZW50VG9UcmVlKGVsLmNoaWxkcmVuKSxcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiB0b1RyZWUodm5vZGUpIHtcclxuICBpZiAodm5vZGUgPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIC8vIFRPRE8obG1yKTogSSdtIG5vdCByZWFsbHkgc3VyZSBJIHVuZGVyc3RhbmQgd2hldGhlciBvciBub3QgdGhpcyBpcyB3aGF0XHJcbiAgLy8gaSBzaG91bGQgYmUgZG9pbmcsIG9yIGlmIHRoaXMgaXMgYSBoYWNrIGZvciBzb21ldGhpbmcgaSdtIGRvaW5nIHdyb25nXHJcbiAgLy8gc29tZXdoZXJlIGVsc2UuIFNob3VsZCB0YWxrIHRvIHNlYmFzdGlhbiBhYm91dCB0aGlzIHBlcmhhcHNcclxuICBjb25zdCBub2RlID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgodm5vZGUpO1xyXG4gIHN3aXRjaCAobm9kZS50YWcpIHtcclxuICAgIGNhc2UgRmliZXJUYWdzLkhvc3RSb290OlxyXG4gICAgICByZXR1cm4gY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCk7XHJcbiAgICBjYXNlIEZpYmVyVGFncy5Ib3N0UG9ydGFsOiB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBzdGF0ZU5vZGU6IHsgY29udGFpbmVySW5mbyB9LFxyXG4gICAgICAgIG1lbW9pemVkUHJvcHM6IGNoaWxkcmVuLFxyXG4gICAgICB9ID0gbm9kZTtcclxuICAgICAgY29uc3QgcHJvcHMgPSB7IGNvbnRhaW5lckluZm8sIGNoaWxkcmVuIH07XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9kZVR5cGU6ICdwb3J0YWwnLFxyXG4gICAgICAgIHR5cGU6IFBvcnRhbCxcclxuICAgICAgICBwcm9wcyxcclxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcclxuICAgICAgICByZWY6IG5vZGUucmVmLFxyXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxyXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKSxcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGNhc2UgRmliZXJUYWdzLkNsYXNzQ29tcG9uZW50OlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG5vZGVUeXBlOiAnY2xhc3MnLFxyXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcclxuICAgICAgICBwcm9wczogeyAuLi5ub2RlLm1lbW9pemVkUHJvcHMgfSxcclxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcclxuICAgICAgICByZWY6IG5vZGUucmVmLFxyXG4gICAgICAgIGluc3RhbmNlOiBub2RlLnN0YXRlTm9kZSxcclxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXHJcbiAgICAgIH07XHJcbiAgICBjYXNlIEZpYmVyVGFncy5GdW5jdGlvbmFsQ29tcG9uZW50OlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG5vZGVUeXBlOiAnZnVuY3Rpb24nLFxyXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcclxuICAgICAgICBwcm9wczogeyAuLi5ub2RlLm1lbW9pemVkUHJvcHMgfSxcclxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcclxuICAgICAgICByZWY6IG5vZGUucmVmLFxyXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxyXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKSxcclxuICAgICAgfTtcclxuICAgIGNhc2UgRmliZXJUYWdzLk1lbW9DbGFzczpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBub2RlVHlwZTogJ2NsYXNzJyxcclxuICAgICAgICB0eXBlOiBub2RlLmVsZW1lbnRUeXBlLnR5cGUsXHJcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5tZW1vaXplZFByb3BzIH0sXHJcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXHJcbiAgICAgICAgcmVmOiBub2RlLnJlZixcclxuICAgICAgICBpbnN0YW5jZTogbm9kZS5zdGF0ZU5vZGUsXHJcbiAgICAgICAgcmVuZGVyZWQ6IGNoaWxkcmVuVG9UcmVlKG5vZGUuY2hpbGQuY2hpbGQpLFxyXG4gICAgICB9O1xyXG4gICAgY2FzZSBGaWJlclRhZ3MuTWVtb1NGQzoge1xyXG4gICAgICBsZXQgcmVuZGVyZWROb2RlcyA9IGZsYXR0ZW4obm9kZUFuZFNpYmxpbmdzQXJyYXkobm9kZS5jaGlsZCkubWFwKHRvVHJlZSkpO1xyXG4gICAgICBpZiAocmVuZGVyZWROb2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZW5kZXJlZE5vZGVzID0gW25vZGUubWVtb2l6ZWRQcm9wcy5jaGlsZHJlbl07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBub2RlVHlwZTogJ2Z1bmN0aW9uJyxcclxuICAgICAgICB0eXBlOiBub2RlLmVsZW1lbnRUeXBlLFxyXG4gICAgICAgIHByb3BzOiB7IC4uLm5vZGUubWVtb2l6ZWRQcm9wcyB9LFxyXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxyXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXHJcbiAgICAgICAgaW5zdGFuY2U6IG51bGwsXHJcbiAgICAgICAgcmVuZGVyZWQ6IHJlbmRlcmVkTm9kZXMsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjYXNlIEZpYmVyVGFncy5Ib3N0Q29tcG9uZW50OiB7XHJcbiAgICAgIGxldCByZW5kZXJlZE5vZGVzID0gZmxhdHRlbihub2RlQW5kU2libGluZ3NBcnJheShub2RlLmNoaWxkKS5tYXAodG9UcmVlKSk7XHJcbiAgICAgIGlmIChyZW5kZXJlZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJlbmRlcmVkTm9kZXMgPSBbbm9kZS5tZW1vaXplZFByb3BzLmNoaWxkcmVuXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG5vZGVUeXBlOiAnaG9zdCcsXHJcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLFxyXG4gICAgICAgIHByb3BzOiB7IC4uLm5vZGUubWVtb2l6ZWRQcm9wcyB9LFxyXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxyXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXHJcbiAgICAgICAgaW5zdGFuY2U6IG5vZGUuc3RhdGVOb2RlLFxyXG4gICAgICAgIHJlbmRlcmVkOiByZW5kZXJlZE5vZGVzLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgY2FzZSBGaWJlclRhZ3MuSG9zdFRleHQ6XHJcbiAgICAgIHJldHVybiBub2RlLm1lbW9pemVkUHJvcHM7XHJcbiAgICBjYXNlIEZpYmVyVGFncy5GcmFnbWVudDpcclxuICAgIGNhc2UgRmliZXJUYWdzLk1vZGU6XHJcbiAgICBjYXNlIEZpYmVyVGFncy5Db250ZXh0UHJvdmlkZXI6XHJcbiAgICBjYXNlIEZpYmVyVGFncy5Db250ZXh0Q29uc3VtZXI6XHJcbiAgICAgIHJldHVybiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKTtcclxuICAgIGNhc2UgRmliZXJUYWdzLlByb2ZpbGVyOlxyXG4gICAgY2FzZSBGaWJlclRhZ3MuRm9yd2FyZFJlZjoge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG5vZGVUeXBlOiAnZnVuY3Rpb24nLFxyXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcclxuICAgICAgICBwcm9wczogeyAuLi5ub2RlLnBlbmRpbmdQcm9wcyB9LFxyXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxyXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXHJcbiAgICAgICAgaW5zdGFuY2U6IG51bGwsXHJcbiAgICAgICAgcmVuZGVyZWQ6IGNoaWxkcmVuVG9UcmVlKG5vZGUuY2hpbGQpLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgY2FzZSBGaWJlclRhZ3MuU3VzcGVuc2U6IHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBub2RlVHlwZTogJ2Z1bmN0aW9uJyxcclxuICAgICAgICB0eXBlOiBTdXNwZW5zZSxcclxuICAgICAgICBwcm9wczogeyAuLi5ub2RlLm1lbW9pemVkUHJvcHMgfSxcclxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcclxuICAgICAgICByZWY6IG5vZGUucmVmLFxyXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxyXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKSxcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGNhc2UgRmliZXJUYWdzLkxhenk6XHJcbiAgICAgIHJldHVybiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKTtcclxuICAgIGNhc2UgRmliZXJUYWdzLk9mZnNjcmVlbkNvbXBvbmVudDpcclxuICAgICAgcmV0dXJuIHRvVHJlZShub2RlLmNoaWxkKTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRW56eW1lIEludGVybmFsIEVycm9yOiB1bmtub3duIG5vZGUgd2l0aCB0YWcgJHtub2RlLnRhZ31gKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoaWxkcmVuVG9UcmVlKG5vZGUpIHtcclxuICBpZiAoIW5vZGUpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICBjb25zdCBjaGlsZHJlbiA9IG5vZGVBbmRTaWJsaW5nc0FycmF5KG5vZGUpO1xyXG4gIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XHJcbiAgICByZXR1cm4gdG9UcmVlKGNoaWxkcmVuWzBdKTtcclxuICB9XHJcbiAgcmV0dXJuIGZsYXR0ZW4oY2hpbGRyZW4ubWFwKHRvVHJlZSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBub2RlVG9Ib3N0Tm9kZShfbm9kZSkge1xyXG4gIC8vIE5PVEUobG1yKTogbm9kZSBjb3VsZCBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudFxyXG4gIC8vIHdoaWNoIHdvbnQgaGF2ZSBhbiBpbnN0YW5jZSBwcm9wLCBidXQgd2UgY2FuIGdldCB0aGVcclxuICAvLyBob3N0IG5vZGUgYXNzb2NpYXRlZCB3aXRoIGl0cyByZXR1cm4gdmFsdWUgYXQgdGhhdCBwb2ludC5cclxuICAvLyBBbHRob3VnaCB0aGlzIGJyZWFrcyBkb3duIGlmIHRoZSByZXR1cm4gdmFsdWUgaXMgYW4gYXJyYXksXHJcbiAgLy8gYXMgaXMgcG9zc2libGUgd2l0aCBSZWFjdCAxNi5cclxuICBsZXQgbm9kZSA9IF9ub2RlO1xyXG4gIHdoaWxlIChub2RlICYmICFBcnJheS5pc0FycmF5KG5vZGUpICYmIG5vZGUuaW5zdGFuY2UgPT09IG51bGwpIHtcclxuICAgIG5vZGUgPSBub2RlLnJlbmRlcmVkO1xyXG4gIH1cclxuICAvLyBpZiB0aGUgU0ZDIHJldHVybmVkIG51bGwgZWZmZWN0aXZlbHksIHRoZXJlIGlzIG5vIGhvc3Qgbm9kZS5cclxuICBpZiAoIW5vZGUpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgbWFwcGVyID0gKGl0ZW0pID0+IHtcclxuICAgIGlmIChpdGVtICYmIGl0ZW0uaW5zdGFuY2UpIHJldHVybiBSZWFjdERPTS5maW5kRE9NTm9kZShpdGVtLmluc3RhbmNlKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH07XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcclxuICAgIHJldHVybiBub2RlLm1hcChtYXBwZXIpO1xyXG4gIH1cclxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlLnJlbmRlcmVkKSAmJiBub2RlLm5vZGVUeXBlID09PSAnY2xhc3MnKSB7XHJcbiAgICByZXR1cm4gbm9kZS5yZW5kZXJlZC5tYXAobWFwcGVyKTtcclxuICB9XHJcbiAgcmV0dXJuIG1hcHBlcihub2RlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVwbGFjZUxhenlXaXRoRmFsbGJhY2sobm9kZSwgZmFsbGJhY2spIHtcclxuICBpZiAoIW5vZGUpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xyXG4gICAgcmV0dXJuIG5vZGUubWFwKChlbCkgPT4gcmVwbGFjZUxhenlXaXRoRmFsbGJhY2soZWwsIGZhbGxiYWNrKSk7XHJcbiAgfVxyXG4gIGlmIChpc0xhenkobm9kZS50eXBlKSkge1xyXG4gICAgcmV0dXJuIGZhbGxiYWNrO1xyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgLi4ubm9kZSxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgIC4uLm5vZGUucHJvcHMsXHJcbiAgICAgIGNoaWxkcmVuOiByZXBsYWNlTGF6eVdpdGhGYWxsYmFjayhub2RlLnByb3BzLmNoaWxkcmVuLCBmYWxsYmFjayksXHJcbiAgICB9LFxyXG4gIH07XHJcbn1cclxuXHJcbmNvbnN0IGV2ZW50T3B0aW9ucyA9IHtcclxuICBhbmltYXRpb246IHRydWUsXHJcbiAgcG9pbnRlckV2ZW50czogaXMxNjQsXHJcbiAgYXV4Q2xpY2s6IGlzMTY1LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2V0RW1wdHlTdGF0ZVZhbHVlKCkge1xyXG4gIC8vIHRoaXMgaGFuZGxlcyBhIGJ1ZyBpbiBSZWFjdCAxNi4wIC0gMTYuMlxyXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvY29tbWl0LzM5YmU4MzU2NWM2NWY5YzUyMjE1MGU1MjM3NTE2NzU2OGEyYTE0NTlcclxuICAvLyBhbHNvIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMTk2NVxyXG5cclxuICBjbGFzcyBFbXB0eVN0YXRlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IHRlc3RSZW5kZXJlciA9IG5ldyBTaGFsbG93UmVuZGVyZXIoKTtcclxuICB0ZXN0UmVuZGVyZXIucmVuZGVyKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRW1wdHlTdGF0ZSkpO1xyXG4gIHJldHVybiB0ZXN0UmVuZGVyZXIuX2luc3RhbmNlLnN0YXRlO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cmFwQWN0KGZuKSB7XHJcbiAgaWYgKCFpczE2OCkge1xyXG4gICAgcmV0dXJuIGZuKCk7XHJcbiAgfVxyXG4gIGxldCByZXR1cm5WYWw7XHJcbiAgVGVzdFV0aWxzLmFjdCgoKSA9PiB7IHJldHVyblZhbCA9IGZuKCk7IH0pO1xyXG4gIHJldHVybiByZXR1cm5WYWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFByb3ZpZGVyRGVmYXVsdFZhbHVlKFByb3ZpZGVyKSB7XHJcbiAgLy8gUmVhY3Qgc3RvcmVzIHJlZmVyZW5jZXMgdG8gdGhlIFByb3ZpZGVyJ3MgZGVmYXVsdFZhbHVlIGRpZmZlcmVudGx5IGFjcm9zcyB2ZXJzaW9ucy5cclxuICBpZiAoJ19kZWZhdWx0VmFsdWUnIGluIFByb3ZpZGVyLl9jb250ZXh0KSB7XHJcbiAgICByZXR1cm4gUHJvdmlkZXIuX2NvbnRleHQuX2RlZmF1bHRWYWx1ZTtcclxuICB9XHJcbiAgaWYgKCdfY3VycmVudFZhbHVlJyBpbiBQcm92aWRlci5fY29udGV4dCkge1xyXG4gICAgcmV0dXJuIFByb3ZpZGVyLl9jb250ZXh0Ll9jdXJyZW50VmFsdWU7XHJcbiAgfVxyXG4gIHRocm93IG5ldyBFcnJvcignRW56eW1lIEludGVybmFsIEVycm9yOiBjYW7igJl0IGZpZ3VyZSBvdXQgaG93IHRvIGdldCBQcm92aWRlcuKAmXMgZGVmYXVsdCB2YWx1ZScpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYWtlRmFrZUVsZW1lbnQodHlwZSkge1xyXG4gIHJldHVybiB7ICQkdHlwZW9mOiBFbGVtZW50LCB0eXBlIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU3RhdGVmdWwoQ29tcG9uZW50KSB7XHJcbiAgcmV0dXJuIENvbXBvbmVudC5wcm90b3R5cGUgJiYgKFxyXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50XHJcbiAgICB8fCBBcnJheS5pc0FycmF5KENvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycykgLy8gZmFsbGJhY2sgZm9yIGNyZWF0ZUNsYXNzIGNvbXBvbmVudHNcclxuICApO1xyXG59XHJcblxyXG5jbGFzcyBSZWFjdFNldmVudGVlbkFkYXB0ZXIgZXh0ZW5kcyBFbnp5bWVBZGFwdGVyIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICBjb25zdCB7IGxpZmVjeWNsZXMgfSA9IHRoaXMub3B0aW9ucztcclxuICAgIHRoaXMub3B0aW9ucyA9IHtcclxuICAgICAgLi4udGhpcy5vcHRpb25zLFxyXG4gICAgICBlbmFibGVDb21wb25lbnREaWRVcGRhdGVPblNldFN0YXRlOiB0cnVlLCAvLyBUT0RPOiByZW1vdmUsIHNlbXZlci1tYWpvclxyXG4gICAgICBsZWdhY3lDb250ZXh0TW9kZTogJ3BhcmVudCcsXHJcbiAgICAgIGxpZmVjeWNsZXM6IHtcclxuICAgICAgICAuLi5saWZlY3ljbGVzLFxyXG4gICAgICAgIGNvbXBvbmVudERpZFVwZGF0ZToge1xyXG4gICAgICAgICAgb25TZXRTdGF0ZTogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczoge1xyXG4gICAgICAgICAgaGFzU2hvdWxkQ29tcG9uZW50VXBkYXRlQnVnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU6IHRydWUsXHJcbiAgICAgICAgc2V0U3RhdGU6IHtcclxuICAgICAgICAgIHNraXBzQ29tcG9uZW50RGlkVXBkYXRlT25OdWxsaXNoOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0Q2hpbGRDb250ZXh0OiB7XHJcbiAgICAgICAgICBjYWxsZWRCeVJlbmRlcmVyOiBmYWxzZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogaXMxNjYsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlTW91bnRSZW5kZXJlcihvcHRpb25zKSB7XHJcbiAgICBhc3NlcnREb21BdmFpbGFibGUoJ21vdW50Jyk7XHJcbiAgICBpZiAoaGFzKG9wdGlvbnMsICdzdXNwZW5zZUZhbGxiYWNrJykpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYHN1c3BlbnNlRmFsbGJhY2tgIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBtb3VudGAgcmVuZGVyZXInKTtcclxuICAgIH1cclxuICAgIGlmIChGaWJlclRhZ3MgPT09IG51bGwpIHtcclxuICAgICAgLy8gUmVxdWlyZXMgRE9NLlxyXG4gICAgICBGaWJlclRhZ3MgPSBkZXRlY3RGaWJlclRhZ3MoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgYXR0YWNoVG8sIGh5ZHJhdGVJbiwgd3JhcHBpbmdDb21wb25lbnRQcm9wcyB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IGRvbU5vZGUgPSBoeWRyYXRlSW4gfHwgYXR0YWNoVG8gfHwgZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgbGV0IGluc3RhbmNlID0gbnVsbDtcclxuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVuZGVyKGVsLCBjb250ZXh0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB3cmFwQWN0KCgpID0+IHtcclxuICAgICAgICAgIGlmIChpbnN0YW5jZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCByZWYgfSA9IGVsO1xyXG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgQ29tcG9uZW50OiB0eXBlLFxyXG4gICAgICAgICAgICAgIHByb3BzLFxyXG4gICAgICAgICAgICAgIHdyYXBwaW5nQ29tcG9uZW50UHJvcHMsXHJcbiAgICAgICAgICAgICAgY29udGV4dCxcclxuICAgICAgICAgICAgICAuLi4ocmVmICYmIHsgcmVmUHJvcDogcmVmIH0pLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBSZWFjdFdyYXBwZXJDb21wb25lbnQgPSBjcmVhdGVNb3VudFdyYXBwZXIoZWwsIHsgLi4ub3B0aW9ucywgYWRhcHRlciB9KTtcclxuICAgICAgICAgICAgY29uc3Qgd3JhcHBlZEVsID0gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdFdyYXBwZXJDb21wb25lbnQsIHdyYXBwZXJQcm9wcyk7XHJcbiAgICAgICAgICAgIGluc3RhbmNlID0gaHlkcmF0ZUluXHJcbiAgICAgICAgICAgICAgPyBSZWFjdERPTS5oeWRyYXRlKHdyYXBwZWRFbCwgZG9tTm9kZSlcclxuICAgICAgICAgICAgICA6IFJlYWN0RE9NLnJlbmRlcih3cmFwcGVkRWwsIGRvbU5vZGUpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0Q2hpbGRQcm9wcyhlbC5wcm9wcywgY29udGV4dCwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICB1bm1vdW50KCkge1xyXG4gICAgICAgIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUoZG9tTm9kZSk7XHJcbiAgICAgICAgaW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICB9LFxyXG4gICAgICBnZXROb2RlKCkge1xyXG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2V0Tm9kZUZyb21Sb290RmluZGVyKFxyXG4gICAgICAgICAgYWRhcHRlci5pc0N1c3RvbUNvbXBvbmVudCxcclxuICAgICAgICAgIHRvVHJlZShpbnN0YW5jZS5fcmVhY3RJbnRlcm5hbHMpLFxyXG4gICAgICAgICAgb3B0aW9ucyxcclxuICAgICAgICApO1xyXG4gICAgICB9LFxyXG4gICAgICBzaW11bGF0ZUVycm9yKG5vZGVIaWVyYXJjaHksIHJvb3ROb2RlLCBlcnJvcikge1xyXG4gICAgICAgIGNvbnN0IGlzRXJyb3JCb3VuZGFyeSA9ICh7IGluc3RhbmNlOiBlbEluc3RhbmNlLCB0eXBlIH0pID0+IHtcclxuICAgICAgICAgIGlmIChpczE2NiAmJiB0eXBlICYmIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGVsSW5zdGFuY2UgJiYgZWxJbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICBpbnN0YW5jZTogY2F0Y2hpbmdJbnN0YW5jZSxcclxuICAgICAgICAgIHR5cGU6IGNhdGNoaW5nVHlwZSxcclxuICAgICAgICB9ID0gbm9kZUhpZXJhcmNoeS5maW5kKGlzRXJyb3JCb3VuZGFyeSkgfHwge307XHJcblxyXG4gICAgICAgIHNpbXVsYXRlRXJyb3IoXHJcbiAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgIGNhdGNoaW5nSW5zdGFuY2UsXHJcbiAgICAgICAgICByb290Tm9kZSxcclxuICAgICAgICAgIG5vZGVIaWVyYXJjaHksXHJcbiAgICAgICAgICBub2RlVHlwZUZyb21UeXBlLFxyXG4gICAgICAgICAgYWRhcHRlci5kaXNwbGF5TmFtZU9mTm9kZSxcclxuICAgICAgICAgIGlzMTY2ID8gY2F0Y2hpbmdUeXBlIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNpbXVsYXRlRXZlbnQobm9kZSwgZXZlbnQsIG1vY2spIHtcclxuICAgICAgICBjb25zdCBtYXBwZWRFdmVudCA9IG1hcE5hdGl2ZUV2ZW50TmFtZXMoZXZlbnQsIGV2ZW50T3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRGbiA9IFRlc3RVdGlscy5TaW11bGF0ZVttYXBwZWRFdmVudF07XHJcbiAgICAgICAgaWYgKCFldmVudEZuKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBSZWFjdFdyYXBwZXI6OnNpbXVsYXRlKCkgZXZlbnQgJyR7ZXZlbnR9JyBkb2VzIG5vdCBleGlzdGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3cmFwQWN0KCgpID0+IHtcclxuICAgICAgICAgIGV2ZW50Rm4oYWRhcHRlci5ub2RlVG9Ib3N0Tm9kZShub2RlKSwgbW9jayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGJhdGNoZWRVcGRhdGVzKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgLy8gcmV0dXJuIFJlYWN0RE9NLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKGZuKTtcclxuICAgICAgfSxcclxuICAgICAgZ2V0V3JhcHBpbmdDb21wb25lbnRSZW5kZXJlcigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgLi4udGhpcyxcclxuICAgICAgICAgIC4uLmdldFdyYXBwaW5nQ29tcG9uZW50TW91bnRSZW5kZXJlcih7XHJcbiAgICAgICAgICAgIHRvVHJlZTogKGluc3QpID0+IHRvVHJlZShpbnN0Ll9yZWFjdEludGVybmFscyksXHJcbiAgICAgICAgICAgIGdldE1vdW50V3JhcHBlckluc3RhbmNlOiAoKSA9PiBpbnN0YW5jZSxcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0sXHJcbiAgICAgIC4uLihpczE2OCAmJiB7IHdyYXBJbnZva2U6IHdyYXBBY3QgfSksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlU2hhbGxvd1JlbmRlcmVyKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXM7XHJcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBTaGFsbG93UmVuZGVyZXIoKTtcclxuICAgIGNvbnN0IHsgc3VzcGVuc2VGYWxsYmFjayB9ID0gb3B0aW9ucztcclxuICAgIGlmICh0eXBlb2Ygc3VzcGVuc2VGYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHN1c3BlbnNlRmFsbGJhY2sgIT09ICdib29sZWFuJykge1xyXG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2BvcHRpb25zLnN1c3BlbnNlRmFsbGJhY2tgIHNob3VsZCBiZSBib29sZWFuIG9yIHVuZGVmaW5lZCcpO1xyXG4gICAgfVxyXG4gICAgbGV0IGlzRE9NID0gZmFsc2U7XHJcbiAgICBsZXQgY2FjaGVkTm9kZSA9IG51bGw7XHJcblxyXG4gICAgbGV0IGxhc3RDb21wb25lbnQgPSBudWxsO1xyXG4gICAgbGV0IHdyYXBwZWRDb21wb25lbnQgPSBudWxsO1xyXG4gICAgY29uc3Qgc2VudGluZWwgPSB7fTtcclxuXHJcbiAgICAvLyB3cmFwIG1lbW8gY29tcG9uZW50cyB3aXRoIGEgUHVyZUNvbXBvbmVudCwgb3IgYSBjbGFzcyBjb21wb25lbnQgd2l0aCBzQ1VcclxuICAgIGNvbnN0IHdyYXBQdXJlQ29tcG9uZW50ID0gKENvbXBvbmVudCwgY29tcGFyZSkgPT4ge1xyXG4gICAgICBpZiAoIWlzMTY2KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBjYWxsZWQgaW4gUmVhY3QgPCAxNi42LiBQbGVhc2UgcmVwb3J0IHRoaXMhJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGxhc3RDb21wb25lbnQgIT09IENvbXBvbmVudCkge1xyXG4gICAgICAgIGlmIChpc1N0YXRlZnVsKENvbXBvbmVudCkpIHtcclxuICAgICAgICAgIHdyYXBwZWRDb21wb25lbnQgPSBjbGFzcyBleHRlbmRzIENvbXBvbmVudCB7fTtcclxuICAgICAgICAgIGlmIChjb21wYXJlKSB7XHJcbiAgICAgICAgICAgIHdyYXBwZWRDb21wb25lbnQucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IChuZXh0UHJvcHMpID0+IChcclxuICAgICAgICAgICAgICAhY29tcGFyZSh0aGlzLnByb3BzLCBuZXh0UHJvcHMpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB3cmFwcGVkQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxldCBtZW1vaXplZCA9IHNlbnRpbmVsO1xyXG4gICAgICAgICAgbGV0IHByZXZQcm9wcztcclxuICAgICAgICAgIHdyYXBwZWRDb21wb25lbnQgPSBmdW5jdGlvbiB3cmFwcGVkQ29tcG9uZW50Rm4ocHJvcHMsIC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkVXBkYXRlID0gbWVtb2l6ZWQgPT09IHNlbnRpbmVsIHx8IChjb21wYXJlXHJcbiAgICAgICAgICAgICAgPyAhY29tcGFyZShwcmV2UHJvcHMsIHByb3BzKVxyXG4gICAgICAgICAgICAgIDogIXNoYWxsb3dFcXVhbChwcmV2UHJvcHMsIHByb3BzKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgbWVtb2l6ZWQgPSBDb21wb25lbnQoeyAuLi5Db21wb25lbnQuZGVmYXVsdFByb3BzLCAuLi5wcm9wcyB9LCAuLi5hcmdzKTtcclxuICAgICAgICAgICAgICBwcmV2UHJvcHMgPSBwcm9wcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWVtb2l6ZWQ7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuYXNzaWduKFxyXG4gICAgICAgICAgd3JhcHBlZENvbXBvbmVudCxcclxuICAgICAgICAgIENvbXBvbmVudCxcclxuICAgICAgICAgIHsgZGlzcGxheU5hbWU6IGFkYXB0ZXIuZGlzcGxheU5hbWVPZk5vZGUoeyB0eXBlOiBDb21wb25lbnQgfSkgfSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGxhc3RDb21wb25lbnQgPSBDb21wb25lbnQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHdyYXBwZWRDb21wb25lbnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFdyYXAgZnVuY3Rpb25hbCBjb21wb25lbnRzIG9uIHZlcnNpb25zIHByaW9yIHRvIDE2LjUsXHJcbiAgICAvLyB0byBhdm9pZCBpbmFkdmVydGVudGx5IHBhc3MgYSBgdGhpc2AgaW5zdGFuY2UgdG8gaXQuXHJcbiAgICBjb25zdCB3cmFwRnVuY3Rpb25hbENvbXBvbmVudCA9IChDb21wb25lbnQpID0+IHtcclxuICAgICAgaWYgKGlzMTY2ICYmIGhhcyhDb21wb25lbnQsICdkZWZhdWx0UHJvcHMnKSkge1xyXG4gICAgICAgIGlmIChsYXN0Q29tcG9uZW50ICE9PSBDb21wb25lbnQpIHtcclxuICAgICAgICAgIHdyYXBwZWRDb21wb25lbnQgPSBPYmplY3QuYXNzaWduKFxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxyXG4gICAgICAgICAgICAocHJvcHMsIC4uLmFyZ3MpID0+IENvbXBvbmVudCh7IC4uLkNvbXBvbmVudC5kZWZhdWx0UHJvcHMsIC4uLnByb3BzIH0sIC4uLmFyZ3MpLFxyXG4gICAgICAgICAgICBDb21wb25lbnQsXHJcbiAgICAgICAgICAgIHsgZGlzcGxheU5hbWU6IGFkYXB0ZXIuZGlzcGxheU5hbWVPZk5vZGUoeyB0eXBlOiBDb21wb25lbnQgfSkgfSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBsYXN0Q29tcG9uZW50ID0gQ29tcG9uZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd3JhcHBlZENvbXBvbmVudDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXMxNjUpIHtcclxuICAgICAgICByZXR1cm4gQ29tcG9uZW50O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobGFzdENvbXBvbmVudCAhPT0gQ29tcG9uZW50KSB7XHJcbiAgICAgICAgd3JhcHBlZENvbXBvbmVudCA9IE9iamVjdC5hc3NpZ24oXHJcbiAgICAgICAgICAoLi4uYXJncykgPT4gQ29tcG9uZW50KC4uLmFyZ3MpLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcclxuICAgICAgICAgIENvbXBvbmVudCxcclxuICAgICAgICApO1xyXG4gICAgICAgIGxhc3RDb21wb25lbnQgPSBDb21wb25lbnQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHdyYXBwZWRDb21wb25lbnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHJlbmRlckVsZW1lbnQgPSAoZWxDb25maWcsIC4uLnJlc3QpID0+IHtcclxuICAgICAgY29uc3QgcmVuZGVyZWRFbCA9IHJlbmRlcmVyLnJlbmRlcihlbENvbmZpZywgLi4ucmVzdCk7XHJcblxyXG4gICAgICBjb25zdCB0eXBlSXNFeGlzdGVkID0gISEocmVuZGVyZWRFbCAmJiByZW5kZXJlZEVsLnR5cGUpO1xyXG4gICAgICBpZiAoaXMxNjYgJiYgdHlwZUlzRXhpc3RlZCkge1xyXG4gICAgICAgIGNvbnN0IGNsb25lZEVsID0gY2hlY2tJc1N1c3BlbnNlQW5kQ2xvbmVFbGVtZW50KHJlbmRlcmVkRWwsIHsgc3VzcGVuc2VGYWxsYmFjayB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgZWxlbWVudElzQ2hhbmdlZCA9IGNsb25lZEVsLnR5cGUgIT09IHJlbmRlcmVkRWwudHlwZTtcclxuICAgICAgICBpZiAoZWxlbWVudElzQ2hhbmdlZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHJlbmRlcmVyLnJlbmRlcih7IC4uLmVsQ29uZmlnLCB0eXBlOiBjbG9uZWRFbC50eXBlIH0sIC4uLnJlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlbmRlcmVkRWw7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJlbmRlcihlbCwgdW5tYXNrZWRDb250ZXh0LCB7XHJcbiAgICAgICAgcHJvdmlkZXJWYWx1ZXMgPSBuZXcgTWFwKCksXHJcbiAgICAgIH0gPSB7fSkge1xyXG4gICAgICAgIGNhY2hlZE5vZGUgPSBlbDtcclxuICAgICAgICAvKiBlc2xpbnQgY29uc2lzdGVudC1yZXR1cm46IDAgKi9cclxuICAgICAgICBpZiAodHlwZW9mIGVsLnR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBpc0RPTSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0NvbnRleHRQcm92aWRlcihlbCkpIHtcclxuICAgICAgICAgIHByb3ZpZGVyVmFsdWVzLnNldChlbC50eXBlLCBlbC5wcm9wcy52YWx1ZSk7XHJcbiAgICAgICAgICBjb25zdCBNb2NrUHJvdmlkZXIgPSBPYmplY3QuYXNzaWduKFxyXG4gICAgICAgICAgICAocHJvcHMpID0+IHByb3BzLmNoaWxkcmVuLFxyXG4gICAgICAgICAgICBlbC50eXBlLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHJlbmRlckVsZW1lbnQoeyAuLi5lbCwgdHlwZTogTW9ja1Byb3ZpZGVyIH0pKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzQ29udGV4dENvbnN1bWVyKGVsKSkge1xyXG4gICAgICAgICAgY29uc3QgUHJvdmlkZXIgPSBhZGFwdGVyLmdldFByb3ZpZGVyRnJvbUNvbnN1bWVyKGVsLnR5cGUpO1xyXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm92aWRlclZhbHVlcy5oYXMoUHJvdmlkZXIpXHJcbiAgICAgICAgICAgID8gcHJvdmlkZXJWYWx1ZXMuZ2V0KFByb3ZpZGVyKVxyXG4gICAgICAgICAgICA6IGdldFByb3ZpZGVyRGVmYXVsdFZhbHVlKFByb3ZpZGVyKTtcclxuICAgICAgICAgIGNvbnN0IE1vY2tDb25zdW1lciA9IE9iamVjdC5hc3NpZ24oXHJcbiAgICAgICAgICAgIChwcm9wcykgPT4gcHJvcHMuY2hpbGRyZW4odmFsdWUpLFxyXG4gICAgICAgICAgICBlbC50eXBlLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHJlbmRlckVsZW1lbnQoeyAuLi5lbCwgdHlwZTogTW9ja0NvbnN1bWVyIH0pKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaXNET00gPSBmYWxzZTtcclxuICAgICAgICAgIGxldCByZW5kZXJlZEVsID0gZWw7XHJcbiAgICAgICAgICBpZiAoaXNMYXp5KHJlbmRlcmVkRWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignYFJlYWN0LmxhenlgIGlzIG5vdCBzdXBwb3J0ZWQgYnkgc2hhbGxvdyByZW5kZXJpbmcuJyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmVuZGVyZWRFbCA9IGNoZWNrSXNTdXNwZW5zZUFuZENsb25lRWxlbWVudChyZW5kZXJlZEVsLCB7IHN1c3BlbnNlRmFsbGJhY2sgfSk7XHJcbiAgICAgICAgICBjb25zdCB7IHR5cGU6IENvbXBvbmVudCB9ID0gcmVuZGVyZWRFbDtcclxuXHJcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dChDb21wb25lbnQuY29udGV4dFR5cGVzLCB1bm1hc2tlZENvbnRleHQpO1xyXG5cclxuICAgICAgICAgIGlmIChpc01lbW8oZWwudHlwZSkpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB0eXBlOiBJbm5lckNvbXAsIGNvbXBhcmUgfSA9IGVsLnR5cGU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiByZW5kZXJFbGVtZW50KFxyXG4gICAgICAgICAgICAgIHsgLi4uZWwsIHR5cGU6IHdyYXBQdXJlQ29tcG9uZW50KElubmVyQ29tcCwgY29tcGFyZSkgfSxcclxuICAgICAgICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgICAgICApKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoIWlzU3RhdGVmdWwoQ29tcG9uZW50KSAmJiB0eXBlb2YgQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHJlbmRlckVsZW1lbnQoXHJcbiAgICAgICAgICAgICAgeyAuLi5yZW5kZXJlZEVsLCB0eXBlOiB3cmFwRnVuY3Rpb25hbENvbXBvbmVudChDb21wb25lbnQpIH0sXHJcbiAgICAgICAgICAgICAgY29udGV4dCxcclxuICAgICAgICAgICAgKSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGlzU3RhdGVmdWwpIHtcclxuICAgICAgICAgICAgLy8gZml4IHJlYWN0IGJ1Zzsgc2VlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRFbXB0eVN0YXRlVmFsdWVgXHJcbiAgICAgICAgICAgIGNvbnN0IGVtcHR5U3RhdGVWYWx1ZSA9IGdldEVtcHR5U3RhdGVWYWx1ZSgpO1xyXG4gICAgICAgICAgICBpZiAoZW1wdHlTdGF0ZVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsICdzdGF0ZScsIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNldCh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGVtcHR5U3RhdGVWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RhdGUnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHJlbmRlckVsZW1lbnQocmVuZGVyZWRFbCwgY29udGV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgdW5tb3VudCgpIHtcclxuICAgICAgICByZW5kZXJlci51bm1vdW50KCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldE5vZGUoKSB7XHJcbiAgICAgICAgaWYgKGlzRE9NKSB7XHJcbiAgICAgICAgICByZXR1cm4gZWxlbWVudFRvVHJlZShjYWNoZWROb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyT3V0cHV0KCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIG5vZGVUeXBlOiBub2RlVHlwZUZyb21UeXBlKGNhY2hlZE5vZGUudHlwZSksXHJcbiAgICAgICAgICB0eXBlOiBjYWNoZWROb2RlLnR5cGUsXHJcbiAgICAgICAgICBwcm9wczogY2FjaGVkTm9kZS5wcm9wcyxcclxuICAgICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQoY2FjaGVkTm9kZS5rZXkpLFxyXG4gICAgICAgICAgcmVmOiBjYWNoZWROb2RlLnJlZixcclxuICAgICAgICAgIGluc3RhbmNlOiByZW5kZXJlci5faW5zdGFuY2UsXHJcbiAgICAgICAgICByZW5kZXJlZDogQXJyYXkuaXNBcnJheShvdXRwdXQpXHJcbiAgICAgICAgICAgID8gZmxhdHRlbihvdXRwdXQpLm1hcCgoZWwpID0+IGVsZW1lbnRUb1RyZWUoZWwpKVxyXG4gICAgICAgICAgICA6IGVsZW1lbnRUb1RyZWUob3V0cHV0KSxcclxuICAgICAgICB9O1xyXG4gICAgICB9LFxyXG4gICAgICBzaW11bGF0ZUVycm9yKG5vZGVIaWVyYXJjaHksIHJvb3ROb2RlLCBlcnJvcikge1xyXG4gICAgICAgIHNpbXVsYXRlRXJyb3IoXHJcbiAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgIHJlbmRlcmVyLl9pbnN0YW5jZSxcclxuICAgICAgICAgIGNhY2hlZE5vZGUsXHJcbiAgICAgICAgICBub2RlSGllcmFyY2h5LmNvbmNhdChjYWNoZWROb2RlKSxcclxuICAgICAgICAgIG5vZGVUeXBlRnJvbVR5cGUsXHJcbiAgICAgICAgICBhZGFwdGVyLmRpc3BsYXlOYW1lT2ZOb2RlLFxyXG4gICAgICAgICAgaXMxNjYgPyBjYWNoZWROb2RlLnR5cGUgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgKTtcclxuICAgICAgfSxcclxuICAgICAgc2ltdWxhdGVFdmVudChub2RlLCBldmVudCwgLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBub2RlLnByb3BzW3Byb3BGcm9tRXZlbnQoZXZlbnQsIGV2ZW50T3B0aW9ucyldO1xyXG4gICAgICAgIGlmIChoYW5kbGVyKSB7XHJcbiAgICAgICAgICB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gVE9ETyhsbXIpOiBjcmVhdGUvdXNlIHN5bnRoZXRpYyBldmVudHNcclxuICAgICAgICAgICAgLy8gVE9ETyhsbXIpOiBlbXVsYXRlIFJlYWN0J3MgZXZlbnQgcHJvcGFnYXRpb25cclxuICAgICAgICAgICAgLy8gUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoKCkgPT4ge1xyXG4gICAgICAgICAgICBoYW5kbGVyKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICAvLyB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgYmF0Y2hlZFVwZGF0ZXMoZm4pIHtcclxuICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgICAgICAvLyByZXR1cm4gUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoZm4pO1xyXG4gICAgICB9LFxyXG4gICAgICBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGhpZXJhcmNoeSkge1xyXG4gICAgICAgIHJldHVybiBjaGVja1Byb3BUeXBlcyhcclxuICAgICAgICAgIHR5cGVTcGVjcyxcclxuICAgICAgICAgIHZhbHVlcyxcclxuICAgICAgICAgIGxvY2F0aW9uLFxyXG4gICAgICAgICAgZGlzcGxheU5hbWVPZk5vZGUoY2FjaGVkTm9kZSksXHJcbiAgICAgICAgICAoKSA9PiBnZXRDb21wb25lbnRTdGFjayhoaWVyYXJjaHkuY29uY2F0KFtjYWNoZWROb2RlXSkpLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlU3RyaW5nUmVuZGVyZXIob3B0aW9ucykge1xyXG4gICAgaWYgKGhhcyhvcHRpb25zLCAnc3VzcGVuc2VGYWxsYmFjaycpKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BzdXNwZW5zZUZhbGxiYWNrYCBzaG91bGQgbm90IGJlIHNwZWNpZmllZCBpbiBvcHRpb25zIG9mIHN0cmluZyByZW5kZXJlcicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVuZGVyKGVsLCBjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGV4dCAmJiAoZWwudHlwZS5jb250ZXh0VHlwZXMgfHwgb3B0aW9ucy5jaGlsZENvbnRleHRUeXBlcykpIHtcclxuICAgICAgICAgIGNvbnN0IGNoaWxkQ29udGV4dFR5cGVzID0ge1xyXG4gICAgICAgICAgICAuLi4oZWwudHlwZS5jb250ZXh0VHlwZXMgfHwge30pLFxyXG4gICAgICAgICAgICAuLi5vcHRpb25zLmNoaWxkQ29udGV4dFR5cGVzLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGNvbnN0IENvbnRleHRXcmFwcGVyID0gY3JlYXRlUmVuZGVyV3JhcHBlcihlbCwgY29udGV4dCwgY2hpbGRDb250ZXh0VHlwZXMpO1xyXG4gICAgICAgICAgcmV0dXJuIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RhdGljTWFya3VwKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dFdyYXBwZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RhdGljTWFya3VwKGVsKTtcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQcm92aWRlZCBhIGJhZyBvZiBvcHRpb25zLCByZXR1cm4gYW4gYEVuenltZVJlbmRlcmVyYC4gU29tZSBvcHRpb25zIGNhbiBiZSBpbXBsZW1lbnRhdGlvblxyXG4gIC8vIHNwZWNpZmljLCBsaWtlIGBhdHRhY2hgIGV0Yy4gZm9yIFJlYWN0LCBidXQgbm90IHBhcnQgb2YgdGhpcyBpbnRlcmZhY2UgZXhwbGljaXRseS5cclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xyXG4gIGNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpIHtcclxuICAgIHN3aXRjaCAob3B0aW9ucy5tb2RlKSB7XHJcbiAgICAgIGNhc2UgRW56eW1lQWRhcHRlci5NT0RFUy5NT1VOVDogcmV0dXJuIHRoaXMuY3JlYXRlTW91bnRSZW5kZXJlcihvcHRpb25zKTtcclxuICAgICAgY2FzZSBFbnp5bWVBZGFwdGVyLk1PREVTLlNIQUxMT1c6IHJldHVybiB0aGlzLmNyZWF0ZVNoYWxsb3dSZW5kZXJlcihvcHRpb25zKTtcclxuICAgICAgY2FzZSBFbnp5bWVBZGFwdGVyLk1PREVTLlNUUklORzogcmV0dXJuIHRoaXMuY3JlYXRlU3RyaW5nUmVuZGVyZXIob3B0aW9ucyk7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbnp5bWUgSW50ZXJuYWwgRXJyb3I6IFVucmVjb2duaXplZCBtb2RlOiAke29wdGlvbnMubW9kZX1gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHdyYXAoZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIHdyYXAoZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICAvLyBjb252ZXJ0cyBhbiBSU1ROb2RlIHRvIHRoZSBjb3JyZXNwb25kaW5nIEpTWCBQcmFnbWEgRWxlbWVudC4gVGhpcyB3aWxsIGJlIG5lZWRlZFxyXG4gIC8vIGluIG9yZGVyIHRvIGltcGxlbWVudCB0aGUgYFdyYXBwZXIubW91bnQoKWAgYW5kIGBXcmFwcGVyLnNoYWxsb3coKWAgbWV0aG9kcywgYnV0IHNob3VsZFxyXG4gIC8vIGJlIHByZXR0eSBzdHJhaWdodGZvcndhcmQgZm9yIHBlb3BsZSB0byBpbXBsZW1lbnQuXHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcclxuICBub2RlVG9FbGVtZW50KG5vZGUpIHtcclxuICAgIGlmICghbm9kZSB8fCB0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHJldHVybiBudWxsO1xyXG4gICAgY29uc3QgeyB0eXBlIH0gPSBub2RlO1xyXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQodW5tZW1vVHlwZSh0eXBlKSwgcHJvcHNXaXRoS2V5c0FuZFJlZihub2RlKSk7XHJcbiAgfVxyXG5cclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xyXG4gIG1hdGNoZXNFbGVtZW50VHlwZShub2RlLCBtYXRjaGluZ1R5cGUpIHtcclxuICAgIGlmICghbm9kZSkge1xyXG4gICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgdHlwZSB9ID0gbm9kZTtcclxuICAgIHJldHVybiB1bm1lbW9UeXBlKHR5cGUpID09PSB1bm1lbW9UeXBlKG1hdGNoaW5nVHlwZSk7XHJcbiAgfVxyXG5cclxuICBlbGVtZW50VG9Ob2RlKGVsZW1lbnQpIHtcclxuICAgIHJldHVybiBlbGVtZW50VG9UcmVlKGVsZW1lbnQpO1xyXG4gIH1cclxuXHJcbiAgbm9kZVRvSG9zdE5vZGUobm9kZSwgc3VwcG9ydHNBcnJheSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBub2RlcyA9IG5vZGVUb0hvc3ROb2RlKG5vZGUpO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpICYmICFzdXBwb3J0c0FycmF5KSB7XHJcbiAgICAgIHJldHVybiBub2Rlc1swXTtcclxuICAgIH1cclxuICAgIHJldHVybiBub2RlcztcclxuICB9XHJcblxyXG4gIGRpc3BsYXlOYW1lT2ZOb2RlKG5vZGUpIHtcclxuICAgIGlmICghbm9kZSkgcmV0dXJuIG51bGw7XHJcbiAgICBjb25zdCB7IHR5cGUsICQkdHlwZW9mIH0gPSBub2RlO1xyXG5cclxuICAgIGNvbnN0IG5vZGVUeXBlID0gdHlwZSB8fCAkJHR5cGVvZjtcclxuXHJcbiAgICAvLyBuZXdlciBub2RlIHR5cGVzIG1heSBiZSB1bmRlZmluZWQsIHNvIG9ubHkgdGVzdCBpZiB0aGUgbm9kZVR5cGUgZXhpc3RzXHJcbiAgICBpZiAobm9kZVR5cGUpIHtcclxuICAgICAgc3dpdGNoIChub2RlVHlwZSkge1xyXG4gICAgICAgIGNhc2UgKGlzMTY2ID8gQ29uY3VycmVudE1vZGUgOiBBc3luY01vZGUpIHx8IE5hTjogcmV0dXJuIGlzMTY2ID8gJ0NvbmN1cnJlbnRNb2RlJyA6ICdBc3luY01vZGUnO1xyXG4gICAgICAgIGNhc2UgRnJhZ21lbnQgfHwgTmFOOiByZXR1cm4gJ0ZyYWdtZW50JztcclxuICAgICAgICBjYXNlIFN0cmljdE1vZGUgfHwgTmFOOiByZXR1cm4gJ1N0cmljdE1vZGUnO1xyXG4gICAgICAgIGNhc2UgUHJvZmlsZXIgfHwgTmFOOiByZXR1cm4gJ1Byb2ZpbGVyJztcclxuICAgICAgICBjYXNlIFBvcnRhbCB8fCBOYU46IHJldHVybiAnUG9ydGFsJztcclxuICAgICAgICBjYXNlIFN1c3BlbnNlIHx8IE5hTjogcmV0dXJuICdTdXNwZW5zZSc7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0ICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcclxuXHJcbiAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xyXG4gICAgICBjYXNlIENvbnRleHRDb25zdW1lciB8fCBOYU46IHJldHVybiAnQ29udGV4dENvbnN1bWVyJztcclxuICAgICAgY2FzZSBDb250ZXh0UHJvdmlkZXIgfHwgTmFOOiByZXR1cm4gJ0NvbnRleHRQcm92aWRlcic7XHJcbiAgICAgIGNhc2UgTWVtbyB8fCBOYU46IHtcclxuICAgICAgICBjb25zdCBub2RlTmFtZSA9IGRpc3BsYXlOYW1lT2ZOb2RlKG5vZGUpO1xyXG4gICAgICAgIHJldHVybiB0eXBlb2Ygbm9kZU5hbWUgPT09ICdzdHJpbmcnID8gbm9kZU5hbWUgOiBgTWVtbygke2Rpc3BsYXlOYW1lT2ZOb2RlKHR5cGUpfSlgO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgRm9yd2FyZFJlZiB8fCBOYU46IHtcclxuICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBkaXNwbGF5TmFtZU9mTm9kZSh7IHR5cGU6IHR5cGUucmVuZGVyIH0pO1xyXG4gICAgICAgIHJldHVybiBuYW1lID8gYEZvcndhcmRSZWYoJHtuYW1lfSlgIDogJ0ZvcndhcmRSZWYnO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgTGF6eSB8fCBOYU46IHtcclxuICAgICAgICByZXR1cm4gJ2xhenknO1xyXG4gICAgICB9XHJcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBkaXNwbGF5TmFtZU9mTm9kZShub2RlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlzVmFsaWRFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgIHJldHVybiBpc0VsZW1lbnQoZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICBpc1ZhbGlkRWxlbWVudFR5cGUob2JqZWN0KSB7XHJcbiAgICByZXR1cm4gISFvYmplY3QgJiYgaXNWYWxpZEVsZW1lbnRUeXBlKG9iamVjdCk7XHJcbiAgfVxyXG5cclxuICBpc0ZyYWdtZW50KGZyYWdtZW50KSB7XHJcbiAgICByZXR1cm4gdHlwZU9mTm9kZShmcmFnbWVudCkgPT09IEZyYWdtZW50O1xyXG4gIH1cclxuXHJcbiAgaXNDdXN0b21Db21wb25lbnQodHlwZSkge1xyXG4gICAgY29uc3QgZmFrZUVsZW1lbnQgPSBtYWtlRmFrZUVsZW1lbnQodHlwZSk7XHJcbiAgICByZXR1cm4gISF0eXBlICYmIChcclxuICAgICAgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbidcclxuICAgICAgfHwgaXNGb3J3YXJkUmVmKGZha2VFbGVtZW50KVxyXG4gICAgICB8fCBpc0NvbnRleHRQcm92aWRlcihmYWtlRWxlbWVudClcclxuICAgICAgfHwgaXNDb250ZXh0Q29uc3VtZXIoZmFrZUVsZW1lbnQpXHJcbiAgICAgIHx8IGlzU3VzcGVuc2UoZmFrZUVsZW1lbnQpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgaXNDb250ZXh0Q29uc3VtZXIodHlwZSkge1xyXG4gICAgcmV0dXJuICEhdHlwZSAmJiBpc0NvbnRleHRDb25zdW1lcihtYWtlRmFrZUVsZW1lbnQodHlwZSkpO1xyXG4gIH1cclxuXHJcbiAgaXNDdXN0b21Db21wb25lbnRFbGVtZW50KGluc3QpIHtcclxuICAgIGlmICghaW5zdCB8fCAhdGhpcy5pc1ZhbGlkRWxlbWVudChpbnN0KSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5pc0N1c3RvbUNvbXBvbmVudChpbnN0LnR5cGUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0UHJvdmlkZXJGcm9tQ29uc3VtZXIoQ29uc3VtZXIpIHtcclxuICAgIC8vIFJlYWN0IHN0b3JlcyByZWZlcmVuY2VzIHRvIHRoZSBQcm92aWRlciBvbiBhIENvbnN1bWVyIGRpZmZlcmVudGx5IGFjcm9zcyB2ZXJzaW9ucy5cclxuICAgIGlmIChDb25zdW1lcikge1xyXG4gICAgICBsZXQgUHJvdmlkZXI7XHJcbiAgICAgIGlmIChDb25zdW1lci5fY29udGV4dCkgeyAvLyBjaGVjayB0aGlzIGZpcnN0LCB0byBhdm9pZCBhIGRlcHJlY2F0aW9uIHdhcm5pbmdcclxuICAgICAgICAoeyBQcm92aWRlciB9ID0gQ29uc3VtZXIuX2NvbnRleHQpO1xyXG4gICAgICB9IGVsc2UgaWYgKENvbnN1bWVyLlByb3ZpZGVyKSB7XHJcbiAgICAgICAgKHsgUHJvdmlkZXIgfSA9IENvbnN1bWVyKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoUHJvdmlkZXIpIHtcclxuICAgICAgICByZXR1cm4gUHJvdmlkZXI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcignRW56eW1lIEludGVybmFsIEVycm9yOiBjYW7igJl0IGZpZ3VyZSBvdXQgaG93IHRvIGdldCBQcm92aWRlciBmcm9tIENvbnN1bWVyJyk7XHJcbiAgfVxyXG5cclxuICBjcmVhdGVFbGVtZW50KC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KC4uLmFyZ3MpO1xyXG4gIH1cclxuXHJcbiAgd3JhcFdpdGhXcmFwcGluZ0NvbXBvbmVudChub2RlLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBSb290RmluZGVyLFxyXG4gICAgICBub2RlOiB3cmFwV2l0aFdyYXBwaW5nQ29tcG9uZW50KFJlYWN0LmNyZWF0ZUVsZW1lbnQsIG5vZGUsIG9wdGlvbnMpLFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXZlbnRlZW5BZGFwdGVyO1xyXG4iXX0=
//# sourceMappingURL=ReactSeventeenAdapter.js.map