{"version":3,"sources":["../src/Utils.ts"],"names":["propKey","breakpointProps","Object","keys","intersection","a1","a2","filter","element","indexOf","createRuleSet","className","query","createClassName","components","reduce","acc","breakpoint","Array","isArray","join","castBreakpointsToIntegers","breakpoints","previous","current","currentIndex","Number"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;AACA;AACO,SAASA,OAAT,CAAiBC,eAAjB,EAAwD;AAC7D,SAAOC,MAAM,CAACC,IAAP,CAAYF,eAAZ,EAA6B,CAA7B,CAAP;AACD;AAED;AACA;AACA;;;AACO,SAASG,YAAT,CACLC,EADK,EAELC,EAFK,EAGE;AACP,SAAOA,EAAE,GAAGD,EAAE,CAACE,MAAH,CAAU,UAAAC,OAAO;AAAA,WAAIF,EAAE,CAACG,OAAH,CAAWD,OAAX,KAAuB,CAA3B;AAAA,GAAjB,CAAH,sBAAwDH,EAAxD,CAAT;AACD;AAED;AACA;AACA;AACA;;;AACO,SAASK,aAAT,CAAuBC,SAAvB,EAA0CC,KAA1C,EAAyD;AAC9D,0BAAiBA,KAAjB,eAA2BD,SAA3B;AACD;AAED;AACA;AACA;;;AACO,SAASE,eAAT,GAEL;AAAA,oCADGC,UACH;AADGA,IAAAA,UACH;AAAA;;AACA,SAAO,CACL,SADK,4BAEFA,UAAU,CAACC,MAAX,CACD,UAACC,GAAD,EAAgBC,UAAhB;AAAA,WACEC,KAAK,CAACC,OAAN,CAAcF,UAAd,uBACQD,GADR,4BACgBC,UADhB,wBAEQD,GAFR,UAEaC,UAFb,EADF;AAAA,GADC,EAKD,EALC,CAFE,GASLG,IATK,CASA,GATA,CAAP;AAUD;AAED;AACA;AACA;;;AACO,SAASC,yBAAT,CAAmCC,WAAnC,EAEuB;AAC5B,MAAMnB,IAAI,GAAGD,MAAM,CAACC,IAAP,CAAYmB,WAAZ,CAAb;AAEA,SAAOnB,IAAI,CAACY,MAAL,CACL,UAACQ,QAAD,EAAWC,OAAX,EAAoBC,YAApB;AAAA,6BACKF,QADL,sBAEGpB,IAAI,CAACsB,YAAD,CAFP,EAEwBC,MAAM,CAACJ,WAAW,CAACE,OAAD,CAAZ,CAF9B;AAAA,GADK,EAKL,EALK,CAAP;AAOD","sourcesContent":["import { MediaBreakpointProps } from \"./Media\"\nimport { BreakpointConstraintKey } from \"./Breakpoints\"\n\n/**\n * Extracts the single breakpoint prop from the props object.\n */\nexport function propKey(breakpointProps: MediaBreakpointProps) {\n  return Object.keys(breakpointProps)[0] as BreakpointConstraintKey\n}\n\n/**\n * Returns the intersection of two arrays.\n */\nexport function intersection(\n  a1: ReadonlyArray<any>,\n  a2?: ReadonlyArray<any>\n): any[] {\n  return a2 ? a1.filter(element => a2.indexOf(element) >= 0) : [...a1]\n}\n\n/**\n * Generate a style rule for a given class name that will hide the element\n * when the given query matches.\n */\nexport function createRuleSet(className: string, query: string) {\n  return `@media ${query}{.${className}{display:none!important;}}`\n}\n\n/**\n * Given a list of strings, or string tuples, generates a class name.\n */\nexport function createClassName(\n  ...components: Array<string | [string, string]>\n) {\n  return [\n    \"fresnel\",\n    ...components.reduce(\n      (acc: string[], breakpoint) =>\n        Array.isArray(breakpoint)\n          ? [...acc, ...breakpoint]\n          : [...acc, breakpoint],\n      []\n    ),\n  ].join(\"-\")\n}\n\n/**\n * Returns an object with every values casted to integers.\n */\nexport function castBreakpointsToIntegers(breakpoints: {\n  [key: string]: number | string\n}): { [key: string]: number } {\n  const keys = Object.keys(breakpoints)\n\n  return keys.reduce(\n    (previous, current, currentIndex) => ({\n      ...previous,\n      [keys[currentIndex]]: Number(breakpoints[current]),\n    }),\n    {}\n  )\n}\n"],"file":"Utils.js"}